// iterators.yrm â€” Iterator pipelines, combinators, and terminators.
//
// Demonstrates: .iter(), .map(), .filter(), .enumerate(), .zip(), .take(), .skip(),
// .collect(), .fold(), .any(), .all(), .find(), .reduce(), .chain(), .rev(),
// .take_while(), .sum(), .count(), .position(), .chars(), .clear(),
// Set.iter(), Map.iter(), zip(range), closures with captures,
// type-transforming maps, break/continue.

fn main() -> int {
    // Basic map: double each element
    let nums: [int] = [1, 2, 3, 4, 5];
    let mut sum: int = 0;
    for x in nums.iter().map(|v: int| -> int { return v * 2; }) {
        sum += x;
    }
    print_str("map double: ");
    print_int(sum);

    // Basic filter: keep evens
    sum = 0;
    for x in nums.iter().filter(|v: int| -> bool { return v % 2 == 0; }) {
        sum += x;
    }
    print_str("filter evens: ");
    print_int(sum);

    // Chained: filter then map
    let data: [int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    sum = 0;
    for x in data.iter().filter(|v: int| -> bool { return v % 2 == 0; }).map(|v: int| -> int { return v * v; }) {
        sum += x;
    }
    print_str("filter-map (even squares): ");
    print_int(sum);

    // Chained: map then filter
    sum = 0;
    for x in data.iter().map(|v: int| -> int { return v * 3; }).filter(|v: int| -> bool { return v > 15; }) {
        sum += x;
    }
    print_str("map-filter (triple > 15): ");
    print_int(sum);

    // Closure with capture
    let threshold: int = 5;
    sum = 0;
    for x in data.iter().filter(|v: int| -> bool { return v > threshold; }) {
        sum += x;
    }
    print_str("filter > threshold: ");
    print_int(sum);

    // Long chain: map, filter, map, filter
    sum = 0;
    for x in data.iter().map(|v: int| -> int { return v * 2; }).filter(|v: int| -> bool { return v > 5; }).map(|v: int| -> int { return v + 1; }).filter(|v: int| -> bool { return v % 2 == 1; }) {
        sum += x;
    }
    print_str("long chain: ");
    print_int(sum);

    // Break in pipeline loop
    sum = 0;
    for x in nums.iter().map(|v: int| -> int { return v * 10; }) {
        if x > 30 {
            break;
        }
        sum += x;
    }
    print_str("break at > 30: ");
    print_int(sum);

    // Continue in pipeline loop
    sum = 0;
    for x in nums.iter().map(|v: int| -> int { return v * 10; }) {
        if x == 30 {
            continue;
        }
        sum += x;
    }
    print_str("skip 30: ");
    print_int(sum);

    // Float pipeline
    let floats: [float] = [1.5, 2.5, 3.5, 4.5];
    let mut fsum: float = 0.0;
    for x in floats.iter().map(|v: float| -> float { return v * 2.0; }) {
        fsum = fsum + x;
    }
    print_str("float map: ");
    print_float(fsum);

    // --- Phase 3: Combinators ---

    // enumerate: get index alongside value
    print_str("\n--- enumerate ---");
    for pair in data.iter().enumerate() {
        let idx: int = pair.0;
        let val: int = pair.1;
        if idx < 3 {
            print_str("  idx=");
            print_int(idx);
            print_str("  val=");
            print_int(val);
        }
    }

    // zip: pair elements from two arrays
    print_str("\n--- zip ---");
    let names: [string] = ["alice", "bob", "charlie"];
    let scores: [int] = [95, 87, 92];
    for pair in names.iter().zip(scores) {
        let name: string = pair.0;
        let score: int = pair.1;
        print_str("  ");
        print_str(name);
        print_str(": ");
        print_int(score);
    }

    // take: only first N elements
    print_str("\n--- take ---");
    sum = 0;
    for x in data.iter().take(3) {
        sum += x;
    }
    print_str("take(3) sum: ");
    print_int(sum);

    // skip: skip first N elements
    print_str("\n--- skip ---");
    sum = 0;
    for x in data.iter().skip(7) {
        sum += x;
    }
    print_str("skip(7) sum: ");
    print_int(sum);

    // skip + enumerate: enumerate resets at 0 after skip
    print_str("\n--- skip + enumerate ---");
    for pair in data.iter().skip(8).enumerate() {
        print_str("  idx=");
        print_int(pair.0);
        print_str("  val=");
        print_int(pair.1);
    }

    // Complex combinator chain: skip, filter, map, take
    print_str("\n--- complex chain ---");
    sum = 0;
    for x in data.iter().skip(1).filter(|v: int| -> bool { return v % 2 == 0; }).map(|v: int| -> int { return v * 10; }).take(3) {
        sum += x;
        print_str("  ");
        print_int(x);
    }
    print_str("chain sum: ");
    print_int(sum);

    // --- Phase 3: Terminators ---

    // collect: materialize filtered/mapped pipeline into new array
    print_str("\n--- collect ---");
    let evens_squared: [int] = data.iter()
        .filter(|v: int| -> bool { return v % 2 == 0; })
        .map(|v: int| -> int { return v * v; })
        .collect();
    print_str("evens squared (len): ");
    print_int(len(evens_squared));
    sum = 0;
    for x in evens_squared.iter() {
        sum += x;
    }
    print_str("evens squared (sum): ");
    print_int(sum);

    // fold: accumulate with initial value
    print_str("\n--- fold ---");
    let total: int = data.iter().fold(0, |acc: int, x: int| -> int { return acc + x; });
    print_str("fold sum 1..10: ");
    print_int(total);

    let product: int = nums.iter().fold(1, |acc: int, x: int| -> int { return acc * x; });
    print_str("fold product 1..5: ");
    print_int(product);

    // any: check if any element satisfies predicate
    print_str("\n--- any ---");
    let has_big: bool = data.iter().any(|v: int| -> bool { return v > 8; });
    print_str("any > 8: ");
    print_bool(has_big);

    let has_negative: bool = data.iter().any(|v: int| -> bool { return v < 0; });
    print_str("any < 0: ");
    print_bool(has_negative);

    // all: check if all elements satisfy predicate
    print_str("\n--- all ---");
    let all_positive: bool = data.iter().all(|v: int| -> bool { return v > 0; });
    print_str("all > 0: ");
    print_bool(all_positive);

    let all_even: bool = data.iter().all(|v: int| -> bool { return v % 2 == 0; });
    print_str("all even: ");
    print_bool(all_even);

    // find: first element matching predicate (returns Option<int>)
    print_str("\n--- find ---");
    let first_gt_5: Option<int> = data.iter().find(|v: int| -> bool { return v > 5; });
    if first_gt_5.is_some() {
        print_str("find > 5: ");
        print_int(first_gt_5.unwrap());
    }

    let first_gt_100: Option<int> = data.iter().find(|v: int| -> bool { return v > 100; });
    if first_gt_100.is_none() {
        print_str("find > 100: none");
    }

    // reduce: accumulate without initial value (returns Option<int>)
    print_str("\n--- reduce ---");
    let reduced: Option<int> = data.iter().reduce(|acc: int, x: int| -> int { return acc + x; });
    if reduced.is_some() {
        print_str("reduce sum: ");
        print_int(reduced.unwrap());
    }

    // Combined: filter + collect + fold
    print_str("\n--- combined pipeline ---");
    let odds: [int] = data.iter()
        .filter(|v: int| -> bool { return v % 2 == 1; })
        .collect();
    let odds_sum: int = odds.iter().fold(0, |acc: int, x: int| -> int { return acc + x; });
    print_str("odd numbers sum: ");
    print_int(odds_sum);

    // --- Range Pipelines ---

    // Range + map + collect: squares of 0..5
    print_str("\n--- range pipelines ---");
    let squares: [int] = (0..5).iter().map(|x: int| -> int { return x * x; }).collect();
    print_str("range map collect (len): ");
    print_int(len(squares));
    sum = 0;
    for x in squares.iter() {
        sum += x;
    }
    print_str("range squares sum: ");
    print_int(sum);

    // Range + filter + fold: sum of evens in 0..20
    let even_sum: int = (0..20).iter()
        .filter(|x: int| -> bool { return x % 2 == 0; })
        .fold(0, |acc: int, x: int| -> int { return acc + x; });
    print_str("range filter fold (even sum 0..20): ");
    print_int(even_sum);

    // Inclusive range + enumerate
    print_str("\n--- inclusive range enumerate ---");
    for pair in (1..=3).iter().enumerate() {
        print_str("  idx=");
        print_int(pair.0);
        print_str("  val=");
        print_int(pair.1);
    }

    // Range + skip + take in for-loop
    print_str("\n--- range skip take ---");
    sum = 0;
    for x in (0..100).iter().skip(10).take(5) {
        sum += x;
        print_str("  ");
        print_int(x);
    }
    print_str("range skip+take sum: ");
    print_int(sum);

    // Chain: concatenate two arrays
    print_str("\n--- chain ---");
    let a: [int] = [1, 2, 3];
    let b: [int] = [4, 5, 6];
    sum = 0;
    for x in a.iter().chain(b) {
        sum += x;
        print_str("  ");
        print_int(x);
    }
    print_str("chain sum: ");
    print_int(sum);

    // Chain + map
    let doubled: [int] = a.iter().chain(b).map(|v: int| -> int { return v * 2; }).collect();
    sum = 0;
    for x in doubled.iter() {
        sum += x;
    }
    print_str("chain+map+collect sum: ");
    print_int(sum);

    // Chain + fold
    let chain_fold: int = a.iter().chain(b).fold(0, |acc: int, x: int| -> int { return acc + x; });
    print_str("chain fold: ");
    print_int(chain_fold);

    // --- clear ---
    print_str("\n--- clear ---");
    let mut clearable: [int] = [10, 20, 30];
    print_str("before clear len: ");
    print_int(len(clearable));
    clearable.clear();
    print_str("after clear len: ");
    print_int(len(clearable));

    // --- sum ---
    print_str("\n--- sum ---");
    let sum_arr: [int] = [1, 2, 3, 4, 5];
    let total_sum: int = sum_arr.iter().sum();
    print_str("sum [1..5]: ");
    print_int(total_sum);

    let filtered_sum: int = sum_arr.iter().filter(|x: int| -> bool { return x > 2; }).sum();
    print_str("sum (>2): ");
    print_int(filtered_sum);

    // --- count ---
    print_str("\n--- count ---");
    let cnt: int = sum_arr.iter().count();
    print_str("count [1..5]: ");
    print_int(cnt);

    let filtered_cnt: int = sum_arr.iter().filter(|x: int| -> bool { return x % 2 == 0; }).count();
    print_str("count (evens): ");
    print_int(filtered_cnt);

    // --- position ---
    print_str("\n--- position ---");
    let pos: Option<int> = sum_arr.iter().position(|x: int| -> bool { return x == 3; });
    match pos {
        Some(idx) => {
            print_str("position of 3: ");
            print_int(idx);
        }
        None => {
            print_str("position of 3: not found");
        }
    }

    let pos_miss: Option<int> = sum_arr.iter().position(|x: int| -> bool { return x == 99; });
    if pos_miss.is_none() {
        print_str("position of 99: none");
    }

    // --- take_while ---
    print_str("\n--- take_while ---");
    sum = 0;
    for x in sum_arr.iter().take_while(|v: int| -> bool { return v < 4; }) {
        sum += x;
    }
    print_str("take_while (<4) sum: ");
    print_int(sum);

    let tw_collected: [int] = sum_arr.iter().take_while(|v: int| -> bool { return v < 4; }).collect();
    print_str("take_while collect len: ");
    print_int(len(tw_collected));

    // --- chars ---
    print_str("\n--- chars ---");
    let greeting: string = "hello";
    let mut char_count: int = 0;
    for c in greeting.chars() {
        char_count += 1;
    }
    print_str("chars count: ");
    print_int(char_count);

    let vowels: [char] = greeting.chars().filter(|c: char| -> bool { return c == 'e' or c == 'o'; }).collect();
    print_str("vowels in hello: ");
    print_int(len(vowels));

    // --- rev ---
    print_str("\n--- rev ---");
    let rev_arr: [int] = [1, 2, 3, 4, 5];
    let mut first_rev: int = 0;
    for x in rev_arr.iter().rev() {
        first_rev = x;
        break;
    }
    print_str("first reversed: ");
    print_int(first_rev);

    let rev_collected: [int] = rev_arr.iter().rev().collect();
    print_str("rev collect len: ");
    print_int(len(rev_collected));

    // --- zip(range) ---
    print_str("\n--- zip(range) ---");
    let zip_arr: [int] = [10, 20, 30];
    let mut idx_sum: int = 0;
    for pair in zip_arr.iter().zip(0..len(zip_arr)) {
        idx_sum += pair.1;
    }
    print_str("zip range idx sum: ");
    print_int(idx_sum);

    // --- Set.iter ---
    print_str("\n--- Set.iter ---");
    let my_set: Set<int> = set_new();
    set_add(my_set, 10);
    set_add(my_set, 20);
    set_add(my_set, 30);
    let mut set_sum: int = 0;
    for x in my_set.iter() {
        set_sum += x;
    }
    print_str("set sum: ");
    print_int(set_sum);

    // --- Map.iter ---
    print_str("\n--- Map.iter ---");
    let m: Map<string, int> = map_new();
    map_set(m, "a", 1);
    map_set(m, "b", 2);
    map_set(m, "c", 3);
    let mut map_val_sum: int = 0;
    for pair in m.iter() {
        let k: string = pair.0;
        let v: int = pair.1;
        map_val_sum += v;
    }
    print_str("map value sum: ");
    print_int(map_val_sum);

    return 0;
}
