module main;

// ═══════════════════════════════════════════════════════════════
//  Token kind constants (used as plain integers)
//
//  Literals:    0=EOF  1=INT_LIT  2=STR_LIT  3=CHAR_LIT
//  Identifier:  5=IDENT
//  Keywords:    10=FN  11=LET  12=MUT  13=RETURN  14=IF  15=ELSE
//               16=WHILE  17=FOR  18=IN  19=MATCH  20=STRUCT
//               21=ENUM  22=MODULE  23=USE  24=CONST  25=PUB
//               26=PURE  27=OWN  28=IMPL  29=TRAIT  30=SELF_TYPE
//               31=SPAWN  32=AND  33=OR  34=NOT  35=TRUE  36=FALSE
//               37=REQUIRES  38=ENSURES  39=EFFECTS
//  Type kw:     40=INT_TYPE  41=FLOAT_TYPE  42=BOOL_TYPE
//               43=STRING_TYPE  44=CHAR_TYPE  45=UNIT_TYPE
//  Delimiters:  50=LPAREN  51=RPAREN  52=LBRACE  53=RBRACE
//               54=LBRACKET  55=RBRACKET
//  Punctuation: 60=COMMA  61=COLON  62=SEMICOLON  63=DOT
//               64=ARROW  65=FAT_ARROW
//  Operators:   70=EQ  71=EQEQ  72=NEQ  73=LT  74=GT
//               75=LTEQ  76=GTEQ  77=PLUS  78=MINUS
//               79=STAR  80=SLASH  81=PERCENT  82=AMPERSAND
//               83=PIPE
//  Special:     90=UNDERSCORE
// ═══════════════════════════════════════════════════════════════

struct Token {
    kind: int,
    int_val: int,
    str_val: string
}

// ═══════════════════════════════════════════════════════════════
//  Keyword lookup
// ═══════════════════════════════════════════════════════════════

fn keyword_lookup(name: string) -> int {
    if str_eq(name, "fn") { return 10; }
    if str_eq(name, "let") { return 11; }
    if str_eq(name, "mut") { return 12; }
    if str_eq(name, "return") { return 13; }
    if str_eq(name, "if") { return 14; }
    if str_eq(name, "else") { return 15; }
    if str_eq(name, "while") { return 16; }
    if str_eq(name, "for") { return 17; }
    if str_eq(name, "in") { return 18; }
    if str_eq(name, "match") { return 19; }
    if str_eq(name, "struct") { return 20; }
    if str_eq(name, "enum") { return 21; }
    if str_eq(name, "module") { return 22; }
    if str_eq(name, "use") { return 23; }
    if str_eq(name, "const") { return 24; }
    if str_eq(name, "pub") { return 25; }
    if str_eq(name, "pure") { return 26; }
    if str_eq(name, "own") { return 27; }
    if str_eq(name, "impl") { return 28; }
    if str_eq(name, "trait") { return 29; }
    if str_eq(name, "Self") { return 30; }
    if str_eq(name, "spawn") { return 31; }
    if str_eq(name, "and") { return 32; }
    if str_eq(name, "or") { return 33; }
    if str_eq(name, "not") { return 34; }
    if str_eq(name, "true") { return 35; }
    if str_eq(name, "false") { return 36; }
    if str_eq(name, "requires") { return 37; }
    if str_eq(name, "ensures") { return 38; }
    if str_eq(name, "effects") { return 39; }
    if str_eq(name, "int") { return 40; }
    if str_eq(name, "float") { return 41; }
    if str_eq(name, "bool") { return 42; }
    if str_eq(name, "string") { return 43; }
    if str_eq(name, "char") { return 44; }
    if str_eq(name, "unit") { return 45; }
    return -1;
}

// ═══════════════════════════════════════════════════════════════
//  Lexer helpers
// ═══════════════════════════════════════════════════════════════

fn make_tok(kind: int, ival: int, sval: string) -> Token {
    let t: Token = Token { kind: kind, int_val: ival, str_val: sval };
    return t;
}

fn lx_at_end(pos: int, slen: int) -> bool {
    return pos >= slen;
}

fn lx_peek(source: string, pos: int, slen: int) -> int {
    if pos >= slen { return -1; }
    return char_to_int(str_charAt(source, pos));
}

fn lx_peek_next(source: string, pos: int, slen: int) -> int {
    if pos + 1 >= slen { return -1; }
    return char_to_int(str_charAt(source, pos + 1));
}

// ═══════════════════════════════════════════════════════════════
//  Skip whitespace and comments — returns new pos
// ═══════════════════════════════════════════════════════════════

fn lx_is_ws(source: string, pos: int, slen: int) -> bool {
    if pos >= slen { return false; }
    return char_is_whitespace(str_charAt(source, pos));
}

fn lx_is_not_nl(source: string, pos: int, slen: int) -> bool {
    if pos >= slen { return false; }
    return lx_peek(source, pos, slen) != 10;
}

fn skip_ws(source: string, start: int, slen: int) -> int {
    let mut pos: int = start;
    let mut again: bool = true;
    while again {
        again = false;

        // Skip whitespace
        while lx_is_ws(source, pos, slen) {
            pos = pos + 1;
        }

        if pos >= slen { return pos; }

        // Skip line comments: //
        if lx_peek(source, pos, slen) == 47 {
            if lx_peek_next(source, pos, slen) == 47 {
                while lx_is_not_nl(source, pos, slen) {
                    pos = pos + 1;
                }
                again = true;
            }
        }

        // Skip block comments: /* ... */ (with nesting)
        if not again {
            if lx_peek(source, pos, slen) == 47 {
                if lx_peek_next(source, pos, slen) == 42 {
                    pos = pos + 2;
                    let mut depth: int = 1;
                    while depth > 0 {
                        if pos >= slen {
                            depth = 0;
                        } else if lx_peek(source, pos, slen) == 47 {
                            if lx_peek_next(source, pos, slen) == 42 {
                                pos = pos + 2;
                                depth = depth + 1;
                            } else {
                                pos = pos + 1;
                            }
                        } else if lx_peek(source, pos, slen) == 42 {
                            if lx_peek_next(source, pos, slen) == 47 {
                                pos = pos + 2;
                                depth = depth - 1;
                            } else {
                                pos = pos + 1;
                            }
                        } else {
                            pos = pos + 1;
                        }
                    }
                    again = true;
                }
            }
        }
    }
    return pos;
}

// ═══════════════════════════════════════════════════════════════
//  Lex number — returns new pos
// ═══════════════════════════════════════════════════════════════

fn lx_is_digit(source: string, pos: int, slen: int) -> bool {
    if pos >= slen { return false; }
    return char_is_digit(str_charAt(source, pos));
}

fn lex_number(source: string, start: int, slen: int, tokens: [Token]) -> int {
    let mut toks: [Token] = tokens;
    let mut pos: int = start;
    while lx_is_digit(source, pos, slen) {
        pos = pos + 1;
    }
    // Handle floats: consume but store as int 0
    if pos < slen {
        if lx_peek(source, pos, slen) == 46 {
            if lx_is_digit(source, pos + 1, slen) {
                pos = pos + 1;
                while lx_is_digit(source, pos, slen) {
                    pos = pos + 1;
                }
            }
        }
    }
    let num_str: string = str_sub(source, start, pos - start);
    let val: int = str_to_int(num_str);
    push(toks, make_tok(1, val, ""));
    return pos;
}

// ═══════════════════════════════════════════════════════════════
//  Lex string literal — returns new pos (opening " already consumed)
// ═══════════════════════════════════════════════════════════════

fn lex_string(source: string, start: int, slen: int, tokens: [Token]) -> int {
    let mut toks: [Token] = tokens;
    let mut pos: int = start;
    let mut val: string = "";
    let mut closed: bool = false;
    while not closed {
        if pos >= slen {
            print_err("error: unterminated string literal\n");
            exit(1);
        }
        let c: int = char_to_int(str_charAt(source, pos));
        pos = pos + 1;
        if c == 34 {
            closed = true;
        } else if c == 92 {
            if pos >= slen {
                print_err("error: unterminated string escape\n");
                exit(1);
            }
            let esc: int = char_to_int(str_charAt(source, pos));
            pos = pos + 1;
            if esc == 110 { val = str_concat(val, str_from_char(int_to_char(10))); }
            else if esc == 116 { val = str_concat(val, str_from_char(int_to_char(9))); }
            else if esc == 114 { val = str_concat(val, str_from_char(int_to_char(13))); }
            else if esc == 92 { val = str_concat(val, str_from_char(int_to_char(92))); }
            else if esc == 34 { val = str_concat(val, str_from_char(int_to_char(34))); }
            else if esc == 48 { val = str_concat(val, str_from_char(int_to_char(0))); }
            else {
                print_err("error: unknown escape in string\n");
                exit(1);
            }
        } else if c == 123 {
            if pos < slen {
                let nb: int = char_to_int(str_charAt(source, pos));
                if nb == 123 { pos = pos + 1; }
            }
            val = str_concat(val, str_from_char(int_to_char(123)));
        } else if c == 125 {
            if pos < slen {
                let nb2: int = char_to_int(str_charAt(source, pos));
                if nb2 == 125 { pos = pos + 1; }
            }
            val = str_concat(val, str_from_char(int_to_char(125)));
        } else {
            val = str_concat(val, str_from_char(int_to_char(c)));
        }
    }
    push(toks, make_tok(2, 0, val));
    return pos;
}

// ═══════════════════════════════════════════════════════════════
//  Lex char literal — returns new pos (opening ' already consumed)
// ═══════════════════════════════════════════════════════════════

fn lex_char_lit(source: string, start: int, slen: int, tokens: [Token]) -> int {
    let mut toks: [Token] = tokens;
    let mut pos: int = start;
    if pos >= slen {
        print_err("error: unterminated char literal\n");
        exit(1);
    }
    let c: int = char_to_int(str_charAt(source, pos));
    pos = pos + 1;
    let mut val: int = c;
    if c == 92 {
        if pos >= slen {
            print_err("error: unterminated char escape\n");
            exit(1);
        }
        let esc: int = char_to_int(str_charAt(source, pos));
        pos = pos + 1;
        if esc == 110 { val = 10; }
        else if esc == 116 { val = 9; }
        else if esc == 114 { val = 13; }
        else if esc == 92 { val = 92; }
        else if esc == 39 { val = 39; }
        else if esc == 48 { val = 0; }
        else {
            print_err("error: unknown char escape\n");
            exit(1);
        }
    }
    if pos >= slen {
        print_err("error: unterminated char literal\n");
        exit(1);
    }
    if char_to_int(str_charAt(source, pos)) != 39 {
        print_err("error: unterminated char literal\n");
        exit(1);
    }
    pos = pos + 1;
    push(toks, make_tok(3, val, ""));
    return pos;
}

// ═══════════════════════════════════════════════════════════════
//  Lex identifier or keyword — returns new pos
//  (first char already consumed, start = pos of first char)
// ═══════════════════════════════════════════════════════════════

fn lx_is_ident_char(source: string, pos: int, slen: int) -> bool {
    if pos >= slen { return false; }
    let ch: char = str_charAt(source, pos);
    if char_is_alpha(ch) { return true; }
    if char_is_digit(ch) { return true; }
    if char_to_int(ch) == 95 { return true; }
    return false;
}

fn lex_ident(source: string, start: int, slen: int, tokens: [Token]) -> int {
    let mut toks: [Token] = tokens;
    let mut pos: int = start + 1;
    while lx_is_ident_char(source, pos, slen) {
        pos = pos + 1;
    }
    return lex_ident_emit(source, start, pos, toks);
}

fn lex_ident_emit(source: string, start: int, pos: int, tokens: [Token]) -> int {
    let mut toks: [Token] = tokens;
    let text: string = str_sub(source, start, pos - start);
    let kw: int = keyword_lookup(text);
    if kw >= 0 {
        push(toks, make_tok(kw, 0, ""));
    } else {
        push(toks, make_tok(5, 0, text));
    }
    return pos;
}

// ═══════════════════════════════════════════════════════════════
//  Main tokenizer
// ═══════════════════════════════════════════════════════════════

fn tokenize(source: string, tokens: [Token]) -> unit {
    let mut toks: [Token] = tokens;
    let slen: int = str_len(source);
    let mut pos: int = 0;
    let mut done: bool = false;
    while not done {
        pos = skip_ws(source, pos, slen);
        if pos >= slen {
            push(toks, make_tok(0, 0, ""));
            done = true;
        } else {
            let c: int = char_to_int(str_charAt(source, pos));
            pos = pos + 1;
            if c == 40 { push(toks, make_tok(50, 0, "")); }
            else if c == 41 { push(toks, make_tok(51, 0, "")); }
            else if c == 123 { push(toks, make_tok(52, 0, "")); }
            else if c == 125 { push(toks, make_tok(53, 0, "")); }
            else if c == 91 { push(toks, make_tok(54, 0, "")); }
            else if c == 93 { push(toks, make_tok(55, 0, "")); }
            else if c == 44 { push(toks, make_tok(60, 0, "")); }
            else if c == 58 { push(toks, make_tok(61, 0, "")); }
            else if c == 59 { push(toks, make_tok(62, 0, "")); }
            else if c == 46 { push(toks, make_tok(63, 0, "")); }
            else if c == 43 { push(toks, make_tok(77, 0, "")); }
            else if c == 42 { push(toks, make_tok(79, 0, "")); }
            else if c == 37 { push(toks, make_tok(81, 0, "")); }
            else if c == 38 { push(toks, make_tok(82, 0, "")); }
            else if c == 124 { push(toks, make_tok(83, 0, "")); }
            else if c == 45 {
                if lx_peek(source, pos, slen) == 62 {
                    pos = pos + 1;
                    push(toks, make_tok(64, 0, ""));
                } else {
                    push(toks, make_tok(78, 0, ""));
                }
            }
            else if c == 61 {
                let np: int = lx_peek(source, pos, slen);
                if np == 61 {
                    pos = pos + 1;
                    push(toks, make_tok(71, 0, ""));
                } else if np == 62 {
                    pos = pos + 1;
                    push(toks, make_tok(65, 0, ""));
                } else {
                    push(toks, make_tok(70, 0, ""));
                }
            }
            else if c == 33 {
                if lx_peek(source, pos, slen) == 61 {
                    pos = pos + 1;
                    push(toks, make_tok(72, 0, ""));
                } else {
                    print_err("error: unexpected '!'\n");
                    exit(1);
                }
            }
            else if c == 60 {
                if lx_peek(source, pos, slen) == 61 {
                    pos = pos + 1;
                    push(toks, make_tok(75, 0, ""));
                } else {
                    push(toks, make_tok(73, 0, ""));
                }
            }
            else if c == 62 {
                if lx_peek(source, pos, slen) == 61 {
                    pos = pos + 1;
                    push(toks, make_tok(76, 0, ""));
                } else {
                    push(toks, make_tok(74, 0, ""));
                }
            }
            else if c == 47 {
                push(toks, make_tok(80, 0, ""));
            }
            else if c == 34 {
                pos = lex_string(source, pos, slen, toks);
            }
            else if c == 39 {
                pos = lex_char_lit(source, pos, slen, toks);
            }
            else if c == 95 {
                if lx_is_ident_char(source, pos, slen) {
                    pos = lex_ident(source, pos - 1, slen, toks);
                } else {
                    push(toks, make_tok(90, 0, ""));
                }
            }
            else if char_is_digit(int_to_char(c)) {
                pos = lex_number(source, pos - 1, slen, toks);
            }
            else if char_is_alpha(int_to_char(c)) {
                pos = lex_ident(source, pos - 1, slen, toks);
            }
            else {
                print_err(str_concat("error: unexpected character: ", str_from_char(int_to_char(c))));
                print_err("\n");
                exit(1);
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════════
//  Token name (for debug printing)
// ═══════════════════════════════════════════════════════════════

fn tok_name(kind: int) -> string {
    if kind == 0 { return "EOF"; }
    if kind == 1 { return "INT"; }
    if kind == 2 { return "STR"; }
    if kind == 3 { return "CHAR"; }
    if kind == 5 { return "IDENT"; }
    if kind == 10 { return "FN"; }
    if kind == 11 { return "LET"; }
    if kind == 12 { return "MUT"; }
    if kind == 13 { return "RETURN"; }
    if kind == 14 { return "IF"; }
    if kind == 15 { return "ELSE"; }
    if kind == 16 { return "WHILE"; }
    if kind == 17 { return "FOR"; }
    if kind == 18 { return "IN"; }
    if kind == 19 { return "MATCH"; }
    if kind == 20 { return "STRUCT"; }
    if kind == 21 { return "ENUM"; }
    if kind == 22 { return "MODULE"; }
    if kind == 25 { return "PUB"; }
    if kind == 26 { return "PURE"; }
    if kind == 32 { return "AND"; }
    if kind == 33 { return "OR"; }
    if kind == 34 { return "NOT"; }
    if kind == 35 { return "TRUE"; }
    if kind == 36 { return "FALSE"; }
    if kind == 37 { return "REQUIRES"; }
    if kind == 38 { return "ENSURES"; }
    if kind == 40 { return "INT_T"; }
    if kind == 41 { return "FLOAT_T"; }
    if kind == 42 { return "BOOL_T"; }
    if kind == 43 { return "STR_T"; }
    if kind == 44 { return "CHAR_T"; }
    if kind == 45 { return "UNIT_T"; }
    if kind == 50 { return "LPAREN"; }
    if kind == 51 { return "RPAREN"; }
    if kind == 52 { return "LBRACE"; }
    if kind == 53 { return "RBRACE"; }
    if kind == 54 { return "LBRACK"; }
    if kind == 55 { return "RBRACK"; }
    if kind == 60 { return "COMMA"; }
    if kind == 61 { return "COLON"; }
    if kind == 62 { return "SEMI"; }
    if kind == 63 { return "DOT"; }
    if kind == 64 { return "ARROW"; }
    if kind == 65 { return "FATARROW"; }
    if kind == 70 { return "EQ"; }
    if kind == 71 { return "EQEQ"; }
    if kind == 72 { return "NEQ"; }
    if kind == 73 { return "LT"; }
    if kind == 74 { return "GT"; }
    if kind == 75 { return "LTEQ"; }
    if kind == 76 { return "GTEQ"; }
    if kind == 77 { return "PLUS"; }
    if kind == 78 { return "MINUS"; }
    if kind == 79 { return "STAR"; }
    if kind == 80 { return "SLASH"; }
    if kind == 81 { return "PERCENT"; }
    if kind == 82 { return "AMP"; }
    if kind == 83 { return "PIPE"; }
    if kind == 90 { return "UNDERSCORE"; }
    return "???";
}

fn print_tokens(tokens: [Token]) -> unit {
    let n: int = len(tokens);
    let mut i: int = 0;
    while i < n {
        let t: Token = tokens[i];
        let name: string = tok_name(t.kind);
        if t.kind == 1 {
            print_str(str_concat(str_concat(name, "("), str_concat(int_to_str(t.int_val), ") ")));
        } else if t.kind == 2 {
            print_str(str_concat(str_concat(name, "(\""), str_concat(t.str_val, "\") ")));
        } else if t.kind == 3 {
            print_str(str_concat(str_concat(name, "("), str_concat(int_to_str(t.int_val), ") ")));
        } else if t.kind == 5 {
            print_str(str_concat(str_concat(name, "("), str_concat(t.str_val, ") ")));
        } else {
            print_str(str_concat(name, " "));
        }
        i = i + 1;
    }
    print_str("\n");
}

// ═══════════════════════════════════════════════════════════════
//  AST Node Pools
//
//  Expr tags:   1=IntLit 2=BoolLit 3=StrLit 4=CharLit 5=Ident
//               6=Binary 7=Unary 8=Call 9=FieldAccess
//               10=MethodCall 11=Index 12=StructInit 13=ArrayLit
//               14=FloatLit
//  Stmt tags:   1=Let 2=Assign 3=Return 4=If 5=While 6=For
//               7=Match 8=ExprStmt
//  TypeNode tags: 1=Int 2=Float 3=Bool 4=Char 5=Str 6=Unit
//                 7=Named 8=Array 9=Map
//  Pattern tags:  1=Wildcard 2=Literal(int) 3=Literal(bool)
//                 4=Literal(str) 5=Binding 6=Variant
// ═══════════════════════════════════════════════════════════════

// AST expression node — integer fields encode children by index
// n1,n2,n3: sub-expression/child indices; s1: name/string data
struct Expr {
    tag: int,
    n1: int,
    n2: int,
    n3: int,
    s1: string
}

// AST statement node
struct Stmt {
    tag: int,
    n1: int,
    n2: int,
    n3: int,
    n4: int,
    s1: string
}

// Block = range in stmts pool
struct Block {
    first: int,
    count: int
}

// Type reference
struct TypeNode {
    tag: int,
    s1: string,
    n1: int
}

// Function declaration
struct FnDecl {
    name: string,
    param_start: int,
    param_count: int,
    ret_type: int,
    body: int
}

// Parameter
struct Param {
    name: string,
    type_idx: int
}

// Struct declaration
struct StructDecl {
    name: string,
    field_start: int,
    field_count: int
}

// Struct field
struct Field {
    name: string,
    type_idx: int
}

// Enum declaration
struct EnumDecl {
    name: string,
    variant_start: int,
    variant_count: int
}

// Enum variant (name + optional field types as idx_list range)
struct Variant {
    name: string,
    field_start: int,
    field_count: int
}

// Match arm
struct MatchArm {
    pat_idx: int,
    body_idx: int
}

// Pattern
struct Pattern {
    tag: int,
    n1: int,
    n2: int,
    s1: string
}

// ═══════════════════════════════════════════════════════════════
//  Global AST pools — filled during parsing
// ═══════════════════════════════════════════════════════════════

fn make_expr(tag: int, n1: int, n2: int, n3: int, s1: string) -> Expr {
    let e: Expr = Expr { tag: tag, n1: n1, n2: n2, n3: n3, s1: s1 };
    return e;
}

fn make_stmt(tag: int, n1: int, n2: int, n3: int, n4: int, s1: string) -> Stmt {
    let s: Stmt = Stmt { tag: tag, n1: n1, n2: n2, n3: n3, n4: n4, s1: s1 };
    return s;
}

fn make_block(first: int, count: int) -> Block {
    let b: Block = Block { first: first, count: count };
    return b;
}

fn make_type(tag: int, s1: string, n1: int) -> TypeNode {
    let t: TypeNode = TypeNode { tag: tag, s1: s1, n1: n1 };
    return t;
}

fn make_fndecl(name: string, ps: int, pc: int, rt: int, body: int) -> FnDecl {
    let f: FnDecl = FnDecl { name: name, param_start: ps, param_count: pc, ret_type: rt, body: body };
    return f;
}

fn make_param(name: string, ti: int) -> Param {
    let p: Param = Param { name: name, type_idx: ti };
    return p;
}

fn make_structdecl(name: string, fs: int, fc: int) -> StructDecl {
    let s: StructDecl = StructDecl { name: name, field_start: fs, field_count: fc };
    return s;
}

fn make_field(name: string, ti: int) -> Field {
    let f: Field = Field { name: name, type_idx: ti };
    return f;
}

fn make_enumdecl(name: string, vs: int, vc: int) -> EnumDecl {
    let e: EnumDecl = EnumDecl { name: name, variant_start: vs, variant_count: vc };
    return e;
}

fn make_variant(name: string, fs: int, fc: int) -> Variant {
    let v: Variant = Variant { name: name, field_start: fs, field_count: fc };
    return v;
}

fn make_matcharm(pi: int, bi: int) -> MatchArm {
    let m: MatchArm = MatchArm { pat_idx: pi, body_idx: bi };
    return m;
}

fn make_pattern(tag: int, n1: int, n2: int, s1: string) -> Pattern {
    let p: Pattern = Pattern { tag: tag, n1: n1, n2: n2, s1: s1 };
    return p;
}

// Push helper for each pool — returns the index of the added element
fn push_expr(pool: [Expr], e: Expr) -> int {
    let idx: int = len(pool);
    let mut p: [Expr] = pool;
    push(p, e);
    return idx;
}

fn push_stmt(pool: [Stmt], s: Stmt) -> int {
    let idx: int = len(pool);
    let mut p: [Stmt] = pool;
    push(p, s);
    return idx;
}

fn push_block(pool: [Block], b: Block) -> int {
    let idx: int = len(pool);
    let mut p: [Block] = pool;
    push(p, b);
    return idx;
}

fn push_type(pool: [TypeNode], t: TypeNode) -> int {
    let idx: int = len(pool);
    let mut p: [TypeNode] = pool;
    push(p, t);
    return idx;
}

fn push_fndecl(pool: [FnDecl], f: FnDecl) -> int {
    let idx: int = len(pool);
    let mut p: [FnDecl] = pool;
    push(p, f);
    return idx;
}

fn push_param(pool: [Param], p: Param) -> int {
    let idx: int = len(pool);
    let mut pp: [Param] = pool;
    push(pp, p);
    return idx;
}

fn push_structdecl(pool: [StructDecl], s: StructDecl) -> int {
    let idx: int = len(pool);
    let mut p: [StructDecl] = pool;
    push(p, s);
    return idx;
}

fn push_field(pool: [Field], f: Field) -> int {
    let idx: int = len(pool);
    let mut p: [Field] = pool;
    push(p, f);
    return idx;
}

fn push_enumdecl(pool: [EnumDecl], e: EnumDecl) -> int {
    let idx: int = len(pool);
    let mut p: [EnumDecl] = pool;
    push(p, e);
    return idx;
}

fn push_variant(pool: [Variant], v: Variant) -> int {
    let idx: int = len(pool);
    let mut p: [Variant] = pool;
    push(p, v);
    return idx;
}

fn push_matcharm(pool: [MatchArm], m: MatchArm) -> int {
    let idx: int = len(pool);
    let mut p: [MatchArm] = pool;
    push(p, m);
    return idx;
}

fn push_pattern(pool: [Pattern], p: Pattern) -> int {
    let idx: int = len(pool);
    let mut pp: [Pattern] = pool;
    push(pp, p);
    return idx;
}

fn push_int(pool: [int], v: int) -> int {
    let idx: int = len(pool);
    let mut p: [int] = pool;
    push(p, v);
    return idx;
}

// ═══════════════════════════════════════════════════════════════
//  Parser error helper
// ═══════════════════════════════════════════════════════════════

fn parse_error(msg: string, tokens: [Token], pos: int) -> unit {
    print_err("parse error: ");
    print_err(msg);
    if pos < len(tokens) {
        let t: Token = tokens[pos];
        print_err(" (at token ");
        print_err(tok_name(t.kind));
        if t.kind == 5 {
            print_err("(");
            print_err(t.str_val);
            print_err(")");
        }
        print_err(")");
    }
    print_err("\n");
    exit(1);
}

// ═══════════════════════════════════════════════════════════════
//  Parser — peek / advance / expect helpers
//  Parser state: tokens array, pos as [int] (single-element array
//  for mutable position sharing across functions)
// ═══════════════════════════════════════════════════════════════

fn pk(tokens: [Token], pos: [int]) -> int {
    return tokens[pos[0]].kind;
}

fn pk_at(tokens: [Token], pos: [int], offset: int) -> int {
    let p: int = pos[0] + offset;
    if p >= len(tokens) { return 0; }
    return tokens[p].kind;
}

fn advance(pos: [int]) -> unit {
    let mut p: [int] = pos;
    p[0] = p[0] + 1;
}

fn expect(tokens: [Token], pos: [int], kind: int) -> unit {
    if pk(tokens, pos) != kind {
        parse_error(str_concat("expected ", tok_name(kind)), tokens, pos[0]);
    }
    advance(pos);
}

fn expect_ident(tokens: [Token], pos: [int]) -> string {
    if pk(tokens, pos) != 5 {
        parse_error("expected identifier", tokens, pos[0]);
    }
    let name: string = tokens[pos[0]].str_val;
    advance(pos);
    return name;
}

// ═══════════════════════════════════════════════════════════════
//  Parse type
// ═══════════════════════════════════════════════════════════════

fn parse_type(tokens: [Token], pos: [int], types: [TypeNode]) -> int {
    let k: int = pk(tokens, pos);
    // [T] = array type
    if k == 54 {
        advance(pos);
        let inner: int = parse_type(tokens, pos, types);
        expect(tokens, pos, 55);
        return push_type(types, make_type(8, "", inner));
    }
    if k == 40 { advance(pos); return push_type(types, make_type(1, "", 0)); }
    if k == 41 { advance(pos); return push_type(types, make_type(2, "", 0)); }
    if k == 42 { advance(pos); return push_type(types, make_type(3, "", 0)); }
    if k == 44 { advance(pos); return push_type(types, make_type(4, "", 0)); }
    if k == 43 { advance(pos); return push_type(types, make_type(5, "", 0)); }
    if k == 45 { advance(pos); return push_type(types, make_type(6, "", 0)); }
    // Map type
    if k == 5 {
        if str_eq(tokens[pos[0]].str_val, "Map") {
            advance(pos);
            return push_type(types, make_type(9, "", 0));
        }
    }
    // Named type (struct/enum)
    if k == 5 {
        let name: string = tokens[pos[0]].str_val;
        advance(pos);
        return push_type(types, make_type(7, name, 0));
    }
    parse_error("expected type", tokens, pos[0]);
    return -1;
}

// ═══════════════════════════════════════════════════════════════
//  Parse pattern (for match arms)
// ═══════════════════════════════════════════════════════════════

fn parse_pattern(tokens: [Token], pos: [int], patterns: [Pattern], idx_lists: [int]) -> int {
    let k: int = pk(tokens, pos);
    // Wildcard: _
    if k == 90 {
        advance(pos);
        return push_pattern(patterns, make_pattern(1, 0, 0, ""));
    }
    // Int literal
    if k == 1 {
        let pat_iv: int = tokens[pos[0]].int_val;
        advance(pos);
        return push_pattern(patterns, make_pattern(2, pat_iv, 0, ""));
    }
    // Negative int literal
    if k == 78 {
        if pk_at(tokens, pos, 1) == 1 {
            advance(pos);
            let pat_nv: int = tokens[pos[0]].int_val;
            advance(pos);
            return push_pattern(patterns, make_pattern(2, 0 - pat_nv, 0, ""));
        }
    }
    // Bool literal
    if k == 35 { advance(pos); return push_pattern(patterns, make_pattern(3, 1, 0, "")); }
    if k == 36 { advance(pos); return push_pattern(patterns, make_pattern(3, 0, 0, "")); }
    // String literal
    if k == 2 {
        let pat_sv: string = tokens[pos[0]].str_val;
        advance(pos);
        return push_pattern(patterns, make_pattern(4, 0, 0, pat_sv));
    }
    // Char literal
    if k == 3 {
        let pat_cv: int = tokens[pos[0]].int_val;
        advance(pos);
        return push_pattern(patterns, make_pattern(2, pat_cv, 0, ""));
    }
    // Identifier: could be variant (if followed by '(') or binding
    if k == 5 {
        let name: string = tokens[pos[0]].str_val;
        advance(pos);
        if pk(tokens, pos) == 50 {
            // Variant with fields: Name(pat1, pat2, ...)
            advance(pos);
            let mut vp_tmp: [int] = [0];
            pop(vp_tmp);
            if pk(tokens, pos) != 51 {
                let sub: int = parse_pattern(tokens, pos, patterns, idx_lists);
                push(vp_tmp, sub);
                while pk(tokens, pos) == 60 {
                    advance(pos);
                    let sub2: int = parse_pattern(tokens, pos, patterns, idx_lists);
                    push(vp_tmp, sub2);
                }
            }
            expect(tokens, pos, 51);
            let start: int = len(idx_lists);
            let count: int = len(vp_tmp);
            let mut vp_j: int = 0;
            while vp_j < count {
                push_int(idx_lists, vp_tmp[vp_j]);
                vp_j = vp_j + 1;
            }
            return push_pattern(patterns, make_pattern(6, start, count, name));
        }
        // Simple binding
        return push_pattern(patterns, make_pattern(5, 0, 0, name));
    }
    parse_error("expected pattern", tokens, pos[0]);
    return -1;
}

// ═══════════════════════════════════════════════════════════════
//  Forward declarations — parse_expr and parse_block are mutually
//  recursive with parse_stmt. In Yorum, we handle this by passing
//  all pools as parameters and structuring the code so that
//  callers appear after callees (Yorum requires textual ordering).
//
//  Actually, Yorum's two-pass approach registers all fn signatures
//  first, so we can call functions defined later. No issue.
// ═══════════════════════════════════════════════════════════════

// Parse expression (entry point) — delegates to Pratt parser
fn parse_expr(tokens: [Token], pos: [int],
              exprs: [Expr], idx_lists: [int]) -> int {
    return parse_expr_bp(tokens, pos, exprs, idx_lists, 0);
}

// Pratt expression parser with minimum binding power
fn parse_expr_bp(tokens: [Token], pos: [int],
                 exprs: [Expr], idx_lists: [int], min_bp: int) -> int {
    let mut left: int = parse_unary(tokens, pos, exprs, idx_lists);
    left = parse_postfix(tokens, pos, exprs, idx_lists, left);

    let mut cont: bool = true;
    while cont {
        let op_kind: int = pk(tokens, pos);
        // Try to get binary operator info: op_code, l_bp, r_bp
        let op_code: int = try_binop(op_kind);
        if op_code < 0 {
            cont = false;
        } else {
            let l_bp: int = binop_lbp(op_code);
            let r_bp: int = binop_rbp(op_code);
            if l_bp < min_bp {
                cont = false;
            } else {
                advance(pos);
                let mut right: int = parse_expr_bp(tokens, pos, exprs, idx_lists, r_bp);
                right = parse_postfix(tokens, pos, exprs, idx_lists, right);
                // Binary expr: n1=left, n2=right, n3=op_code
                left = push_expr(exprs, make_expr(6, left, right, op_code, ""));
            }
        }
    }
    return left;
}

// Map token kind to binary op code, or -1 if not a binary op
// Op codes: 1=Add 2=Sub 3=Mul 4=Div 5=Mod 6=Eq 7=Neq
//           8=Lt 9=Gt 10=Lteq 11=Gteq 12=And 13=Or
fn try_binop(tk: int) -> int {
    if tk == 77 { return 1; }
    if tk == 78 { return 2; }
    if tk == 79 { return 3; }
    if tk == 80 { return 4; }
    if tk == 81 { return 5; }
    if tk == 71 { return 6; }
    if tk == 72 { return 7; }
    if tk == 73 { return 8; }
    if tk == 74 { return 9; }
    if tk == 75 { return 10; }
    if tk == 76 { return 11; }
    if tk == 32 { return 12; }
    if tk == 33 { return 13; }
    return -1;
}

// Left binding power for binary op code
fn binop_lbp(op: int) -> int {
    if op == 13 { return 1; }
    if op == 12 { return 3; }
    if op == 6 { return 5; }
    if op == 7 { return 5; }
    if op == 8 { return 7; }
    if op == 9 { return 7; }
    if op == 10 { return 7; }
    if op == 11 { return 7; }
    if op == 1 { return 9; }
    if op == 2 { return 9; }
    if op == 3 { return 11; }
    if op == 4 { return 11; }
    if op == 5 { return 11; }
    return 0;
}

// Right binding power for binary op code
fn binop_rbp(op: int) -> int {
    if op == 13 { return 2; }
    if op == 12 { return 4; }
    if op == 6 { return 6; }
    if op == 7 { return 6; }
    if op == 8 { return 8; }
    if op == 9 { return 8; }
    if op == 10 { return 8; }
    if op == 11 { return 8; }
    if op == 1 { return 10; }
    if op == 2 { return 10; }
    if op == 3 { return 12; }
    if op == 4 { return 12; }
    if op == 5 { return 12; }
    return 0;
}

// Parse unary prefix: -expr, not expr, or primary
fn parse_unary(tokens: [Token], pos: [int],
               exprs: [Expr], idx_lists: [int]) -> int {
    let k: int = pk(tokens, pos);
    // Unary minus
    if k == 78 {
        advance(pos);
        let neg_op: int = parse_unary(tokens, pos, exprs, idx_lists);
        // Unary expr: n1=operand, n2=op (1=Neg, 2=Not)
        return push_expr(exprs, make_expr(7, neg_op, 1, 0, ""));
    }
    // Unary not
    if k == 34 {
        advance(pos);
        let not_op: int = parse_unary(tokens, pos, exprs, idx_lists);
        return push_expr(exprs, make_expr(7, not_op, 2, 0, ""));
    }
    return parse_primary(tokens, pos, exprs, idx_lists);
}

// Parse postfix: function call, field access, method call, indexing
fn parse_postfix(tokens: [Token], pos: [int],
                 exprs: [Expr], idx_lists: [int], base: int) -> int {
    let mut result: int = base;
    let mut cont: bool = true;
    while cont {
        let k: int = pk(tokens, pos);
        if k == 50 {
            // Function call: expr(args...)
            advance(pos);
            let mut ca_tmp: [int] = [0];
            pop(ca_tmp);
            if pk(tokens, pos) != 51 {
                let a: int = parse_expr(tokens, pos, exprs, idx_lists);
                push(ca_tmp, a);
                while pk(tokens, pos) == 60 {
                    advance(pos);
                    let a2: int = parse_expr(tokens, pos, exprs, idx_lists);
                    push(ca_tmp, a2);
                }
            }
            expect(tokens, pos, 51);
            let arg_start: int = len(idx_lists);
            let arg_count: int = len(ca_tmp);
            let mut ca_i: int = 0;
            while ca_i < arg_count {
                push_int(idx_lists, ca_tmp[ca_i]);
                ca_i = ca_i + 1;
            }
            // Call expr: n1=callee, n2=arg_start, n3=arg_count
            result = push_expr(exprs, make_expr(8, result, arg_start, arg_count, ""));
        } else if k == 63 {
            // Field access or method call: expr.name or expr.name(args...)
            advance(pos);
            let fname: string = expect_ident(tokens, pos);
            if pk(tokens, pos) == 50 {
                // Method call: expr.name(args...)
                advance(pos);
                let mut ma_tmp: [int] = [0];
                pop(ma_tmp);
                if pk(tokens, pos) != 51 {
                    let ma: int = parse_expr(tokens, pos, exprs, idx_lists);
                    push(ma_tmp, ma);
                    while pk(tokens, pos) == 60 {
                        advance(pos);
                        let ma2: int = parse_expr(tokens, pos, exprs, idx_lists);
                        push(ma_tmp, ma2);
                    }
                }
                expect(tokens, pos, 51);
                let m_arg_start: int = len(idx_lists);
                let m_arg_count: int = len(ma_tmp);
                let mut ma_i: int = 0;
                while ma_i < m_arg_count {
                    push_int(idx_lists, ma_tmp[ma_i]);
                    ma_i = ma_i + 1;
                }
                // MethodCall expr: n1=receiver, n2=arg_start, n3=arg_count, s1=method_name
                result = push_expr(exprs, make_expr(10, result, m_arg_start, m_arg_count, fname));
            } else {
                // Field access: n1=object, s1=field_name
                result = push_expr(exprs, make_expr(9, result, 0, 0, fname));
            }
        } else if k == 54 {
            // Indexing: expr[index]
            advance(pos);
            let idx_expr: int = parse_expr(tokens, pos, exprs, idx_lists);
            expect(tokens, pos, 55);
            // Index expr: n1=array, n2=index
            result = push_expr(exprs, make_expr(11, result, idx_expr, 0, ""));
        } else {
            cont = false;
        }
    }
    return result;
}

// Check if next tokens look like struct init: IDENT { IDENT : ...
// or empty struct: IDENT { }
fn is_struct_init(tokens: [Token], pos: [int]) -> bool {
    // Current token should be LBrace (52)
    // Look ahead: { IDENT : ... } or { }
    let p: int = pos[0];
    if p + 1 >= len(tokens) { return false; }
    let next: int = tokens[p + 1].kind;
    // { } = empty struct init
    if tokens[p].kind == 52 {
        if next == 53 { return true; }
        // { IDENT : ... = struct init
        if next == 5 {
            if p + 2 < len(tokens) {
                if tokens[p + 2].kind == 61 { return true; }
            }
        }
    }
    return false;
}

// Parse primary expression
fn parse_primary(tokens: [Token], pos: [int],
                 exprs: [Expr], idx_lists: [int]) -> int {
    let k: int = pk(tokens, pos);

    // Integer literal
    if k == 1 {
        let int_v: int = tokens[pos[0]].int_val;
        advance(pos);
        return push_expr(exprs, make_expr(1, int_v, 0, 0, ""));
    }

    // String literal
    if k == 2 {
        let str_v: string = tokens[pos[0]].str_val;
        advance(pos);
        return push_expr(exprs, make_expr(3, 0, 0, 0, str_v));
    }

    // Char literal
    if k == 3 {
        let char_v: int = tokens[pos[0]].int_val;
        advance(pos);
        return push_expr(exprs, make_expr(4, char_v, 0, 0, ""));
    }

    // Bool literal: true
    if k == 35 {
        advance(pos);
        return push_expr(exprs, make_expr(2, 1, 0, 0, ""));
    }
    // Bool literal: false
    if k == 36 {
        advance(pos);
        return push_expr(exprs, make_expr(2, 0, 0, 0, ""));
    }

    // Identifier — possibly followed by struct init { ... }
    if k == 5 {
        let name: string = tokens[pos[0]].str_val;
        advance(pos);
        // Check for struct init: Name { field: value, ... }
        if pk(tokens, pos) == 52 {
            if is_struct_init(tokens, pos) {
                advance(pos);
                let mut fi_tmp: [int] = [0];
                pop(fi_tmp);
                let mut fi_count: int = 0;
                if pk(tokens, pos) != 53 {
                    let fn1: string = expect_ident(tokens, pos);
                    expect(tokens, pos, 61);
                    let fv1: int = parse_expr(tokens, pos, exprs, idx_lists);
                    let name_e: int = push_expr(exprs, make_expr(3, 0, 0, 0, fn1));
                    push(fi_tmp, name_e);
                    push(fi_tmp, fv1);
                    fi_count = fi_count + 1;
                    while pk(tokens, pos) == 60 {
                        advance(pos);
                        if pk(tokens, pos) == 53 {
                            // trailing comma
                        } else {
                            let fn2: string = expect_ident(tokens, pos);
                            expect(tokens, pos, 61);
                            let fv2: int = parse_expr(tokens, pos, exprs, idx_lists);
                            let name_e2: int = push_expr(exprs, make_expr(3, 0, 0, 0, fn2));
                            push(fi_tmp, name_e2);
                            push(fi_tmp, fv2);
                            fi_count = fi_count + 1;
                        }
                    }
                }
                expect(tokens, pos, 53);
                let fi_start: int = len(idx_lists);
                let mut fi_j: int = 0;
                while fi_j < len(fi_tmp) {
                    push_int(idx_lists, fi_tmp[fi_j]);
                    fi_j = fi_j + 1;
                }
                // StructInit: n1=fi_start, n2=fi_count (each field = 2 idx_list entries)
                return push_expr(exprs, make_expr(12, fi_start, fi_count, 0, name));
            }
        }
        // Plain identifier
        return push_expr(exprs, make_expr(5, 0, 0, 0, name));
    }

    // Array literal: [expr, expr, ...]
    if k == 54 {
        advance(pos);
        let mut el_tmp: [int] = [0];
        pop(el_tmp);
        if pk(tokens, pos) != 55 {
            let e1: int = parse_expr(tokens, pos, exprs, idx_lists);
            push(el_tmp, e1);
            while pk(tokens, pos) == 60 {
                advance(pos);
                if pk(tokens, pos) == 55 {
                    // trailing comma
                } else {
                    let e2: int = parse_expr(tokens, pos, exprs, idx_lists);
                    push(el_tmp, e2);
                }
            }
        }
        expect(tokens, pos, 55);
        let el_start: int = len(idx_lists);
        let el_count: int = len(el_tmp);
        let mut el_j: int = 0;
        while el_j < el_count {
            push_int(idx_lists, el_tmp[el_j]);
            el_j = el_j + 1;
        }
        // ArrayLit: n1=el_start, n2=el_count
        return push_expr(exprs, make_expr(13, el_start, el_count, 0, ""));
    }

    // Parenthesized expression
    if k == 50 {
        advance(pos);
        let inner: int = parse_expr(tokens, pos, exprs, idx_lists);
        expect(tokens, pos, 51);
        return inner;
    }

    parse_error("expected expression", tokens, pos[0]);
    return -1;
}

// ═══════════════════════════════════════════════════════════════
//  Parse statements and blocks
// ═══════════════════════════════════════════════════════════════

fn parse_block(tokens: [Token], pos: [int],
               exprs: [Expr], stmts: [Stmt], blocks: [Block],
               types: [TypeNode], idx_lists: [int],
               patterns: [Pattern], match_arms: [MatchArm]) -> int {
    expect(tokens, pos, 52);
    let mut blk_ids: [int] = [0];
    pop(blk_ids);
    while pk(tokens, pos) != 53 {
        if pk(tokens, pos) == 0 {
            parse_error("unexpected EOF in block", tokens, pos[0]);
        }
        let blk_si: int = parse_stmt(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
        push(blk_ids, blk_si);
    }
    expect(tokens, pos, 53);
    let blk_first: int = len(idx_lists);
    let blk_count: int = len(blk_ids);
    let mut blk_j: int = 0;
    while blk_j < blk_count {
        push(idx_lists, blk_ids[blk_j]);
        blk_j = blk_j + 1;
    }
    return push_block(blocks, make_block(blk_first, blk_count));
}

fn parse_stmt(tokens: [Token], pos: [int],
              exprs: [Expr], stmts: [Stmt], blocks: [Block],
              types: [TypeNode], idx_lists: [int],
              patterns: [Pattern], match_arms: [MatchArm]) -> int {
    let k: int = pk(tokens, pos);

    // Let statement: let [mut] name : type = expr ;
    if k == 11 {
        return parse_let(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
    }

    // Return statement: return [expr] ;
    if k == 13 {
        return parse_return(tokens, pos, exprs, stmts, idx_lists);
    }

    // If statement
    if k == 14 {
        return parse_if(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
    }

    // While statement
    if k == 16 {
        return parse_while(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
    }

    // For statement
    if k == 17 {
        return parse_for(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
    }

    // Match statement
    if k == 19 {
        return parse_match(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
    }

    // Expression statement or assignment
    return parse_expr_or_assign(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
}

fn parse_let(tokens: [Token], pos: [int],
             exprs: [Expr], stmts: [Stmt], blocks: [Block],
             types: [TypeNode], idx_lists: [int],
             patterns: [Pattern], match_arms: [MatchArm]) -> int {
    advance(pos);
    let mut is_mut: int = 0;
    if pk(tokens, pos) == 12 {
        is_mut = 1;
        advance(pos);
    }
    let name: string = expect_ident(tokens, pos);
    expect(tokens, pos, 61);
    let ty: int = parse_type(tokens, pos, types);
    expect(tokens, pos, 70);
    let val: int = parse_expr(tokens, pos, exprs, idx_lists);
    expect(tokens, pos, 62);
    // Let stmt: n1=type_idx, n2=value_expr, n3=is_mut, s1=name
    return push_stmt(stmts, make_stmt(1, ty, val, is_mut, 0, name));
}

fn parse_return(tokens: [Token], pos: [int],
                exprs: [Expr], stmts: [Stmt], idx_lists: [int]) -> int {
    advance(pos);
    // return ; => return 0 (for unit functions, value is ignored)
    if pk(tokens, pos) == 62 {
        advance(pos);
        let zero: int = push_expr(exprs, make_expr(1, 0, 0, 0, ""));
        return push_stmt(stmts, make_stmt(3, zero, 0, 0, 0, ""));
    }
    let val: int = parse_expr(tokens, pos, exprs, idx_lists);
    expect(tokens, pos, 62);
    // Return stmt: n1=value_expr
    return push_stmt(stmts, make_stmt(3, val, 0, 0, 0, ""));
}

fn parse_if(tokens: [Token], pos: [int],
            exprs: [Expr], stmts: [Stmt], blocks: [Block],
            types: [TypeNode], idx_lists: [int],
            patterns: [Pattern], match_arms: [MatchArm]) -> int {
    advance(pos);
    let cond: int = parse_expr(tokens, pos, exprs, idx_lists);
    let then_b: int = parse_block(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
    let mut else_b: int = -1;
    let mut else_if_stmt: int = -1;
    if pk(tokens, pos) == 15 {
        advance(pos);
        if pk(tokens, pos) == 14 {
            // else if => recursive, store as stmt index (negative offset to distinguish)
            else_if_stmt = parse_if(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
        } else {
            // else { block }
            else_b = parse_block(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
        }
    }
    // If stmt: n1=cond, n2=then_block, n3=else_block (-1=none), n4=else_if_stmt (-1=none)
    return push_stmt(stmts, make_stmt(4, cond, then_b, else_b, else_if_stmt, ""));
}

fn parse_while(tokens: [Token], pos: [int],
               exprs: [Expr], stmts: [Stmt], blocks: [Block],
               types: [TypeNode], idx_lists: [int],
               patterns: [Pattern], match_arms: [MatchArm]) -> int {
    advance(pos);
    let cond: int = parse_expr(tokens, pos, exprs, idx_lists);
    let body: int = parse_block(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
    // While stmt: n1=cond, n2=body_block
    return push_stmt(stmts, make_stmt(5, cond, body, 0, 0, ""));
}

fn parse_for(tokens: [Token], pos: [int],
             exprs: [Expr], stmts: [Stmt], blocks: [Block],
             types: [TypeNode], idx_lists: [int],
             patterns: [Pattern], match_arms: [MatchArm]) -> int {
    advance(pos);
    let var_name: string = expect_ident(tokens, pos);
    expect(tokens, pos, 18);
    let iterable: int = parse_expr(tokens, pos, exprs, idx_lists);
    let body: int = parse_block(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
    // For stmt: n1=iterable, n2=body_block, s1=var_name
    return push_stmt(stmts, make_stmt(6, iterable, body, 0, 0, var_name));
}

fn parse_match(tokens: [Token], pos: [int],
               exprs: [Expr], stmts: [Stmt], blocks: [Block],
               types: [TypeNode], idx_lists: [int],
               patterns: [Pattern], match_arms: [MatchArm]) -> int {
    advance(pos);
    let subject: int = parse_expr(tokens, pos, exprs, idx_lists);
    expect(tokens, pos, 52);
    let mut arm_tmp: [int] = [0];
    pop(arm_tmp);
    while pk(tokens, pos) != 53 {
        if pk(tokens, pos) == 0 {
            parse_error("unexpected EOF in match", tokens, pos[0]);
        }
        let pat: int = parse_pattern(tokens, pos, patterns, idx_lists);
        expect(tokens, pos, 65);
        let body: int = parse_block(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
        let arm: int = push_matcharm(match_arms, make_matcharm(pat, body));
        push(arm_tmp, arm);
        // Optional comma between arms
        if pk(tokens, pos) == 60 {
            advance(pos);
        }
    }
    expect(tokens, pos, 53);
    let arm_start: int = len(idx_lists);
    let arm_count: int = len(arm_tmp);
    let mut arm_j: int = 0;
    while arm_j < arm_count {
        push_int(idx_lists, arm_tmp[arm_j]);
        arm_j = arm_j + 1;
    }
    // Match stmt: n1=subject, n2=arm_start, n3=arm_count
    return push_stmt(stmts, make_stmt(7, subject, arm_start, arm_count, 0, ""));
}

fn parse_expr_or_assign(tokens: [Token], pos: [int],
                        exprs: [Expr], stmts: [Stmt], blocks: [Block],
                        types: [TypeNode], idx_lists: [int],
                        patterns: [Pattern], match_arms: [MatchArm]) -> int {
    let lhs: int = parse_expr(tokens, pos, exprs, idx_lists);
    if pk(tokens, pos) == 70 {
        // Assignment: lhs = rhs ;
        advance(pos);
        let rhs: int = parse_expr(tokens, pos, exprs, idx_lists);
        expect(tokens, pos, 62);
        // Assign stmt: n1=target, n2=value
        return push_stmt(stmts, make_stmt(2, lhs, rhs, 0, 0, ""));
    }
    expect(tokens, pos, 62);
    // Expr stmt: n1=expr
    return push_stmt(stmts, make_stmt(8, lhs, 0, 0, 0, ""));
}

// ═══════════════════════════════════════════════════════════════
//  Parse declarations (top-level)
// ═══════════════════════════════════════════════════════════════

fn parse_fn_decl(tokens: [Token], pos: [int],
                 exprs: [Expr], stmts: [Stmt], blocks: [Block],
                 types: [TypeNode], params: [Param],
                 fn_decls: [FnDecl], idx_lists: [int],
                 patterns: [Pattern], match_arms: [MatchArm]) -> int {
    expect(tokens, pos, 10);
    let name: string = expect_ident(tokens, pos);
    expect(tokens, pos, 50);
    let ps: int = len(params);
    let mut pc: int = 0;
    if pk(tokens, pos) != 51 {
        let pname: string = expect_ident(tokens, pos);
        expect(tokens, pos, 61);
        let pty: int = parse_type(tokens, pos, types);
        push_param(params, make_param(pname, pty));
        pc = pc + 1;
        while pk(tokens, pos) == 60 {
            advance(pos);
            let pname2: string = expect_ident(tokens, pos);
            expect(tokens, pos, 61);
            let pty2: int = parse_type(tokens, pos, types);
            push_param(params, make_param(pname2, pty2));
            pc = pc + 1;
        }
    }
    expect(tokens, pos, 51);
    // Return type
    let mut ret: int = push_type(types, make_type(6, "", 0));
    if pk(tokens, pos) == 64 {
        advance(pos);
        ret = parse_type(tokens, pos, types);
    }
    // Skip contracts (requires/ensures/effects) - just parse expressions
    while pk(tokens, pos) == 37 {
        advance(pos);
        parse_expr(tokens, pos, exprs, idx_lists);
    }
    while pk(tokens, pos) == 38 {
        advance(pos);
        parse_expr(tokens, pos, exprs, idx_lists);
    }
    while pk(tokens, pos) == 39 {
        advance(pos);
        // effects is a list of identifiers
        expect_ident(tokens, pos);
        while pk(tokens, pos) == 60 {
            advance(pos);
            expect_ident(tokens, pos);
        }
    }
    let body: int = parse_block(tokens, pos, exprs, stmts, blocks, types, idx_lists, patterns, match_arms);
    return push_fndecl(fn_decls, make_fndecl(name, ps, pc, ret, body));
}

fn parse_struct_decl(tokens: [Token], pos: [int],
                     types: [TypeNode], fields: [Field],
                     struct_decls: [StructDecl]) -> int {
    expect(tokens, pos, 20);
    let name: string = expect_ident(tokens, pos);
    expect(tokens, pos, 52);
    let fs: int = len(fields);
    let mut fc: int = 0;
    if pk(tokens, pos) != 53 {
        let fname: string = expect_ident(tokens, pos);
        expect(tokens, pos, 61);
        let fty: int = parse_type(tokens, pos, types);
        push_field(fields, make_field(fname, fty));
        fc = fc + 1;
        while pk(tokens, pos) == 60 {
            advance(pos);
            if pk(tokens, pos) == 53 {
                // trailing comma
            } else {
                let fname2: string = expect_ident(tokens, pos);
                expect(tokens, pos, 61);
                let fty2: int = parse_type(tokens, pos, types);
                push_field(fields, make_field(fname2, fty2));
                fc = fc + 1;
            }
        }
    }
    expect(tokens, pos, 53);
    return push_structdecl(struct_decls, make_structdecl(name, fs, fc));
}

fn parse_enum_decl(tokens: [Token], pos: [int],
                   types: [TypeNode], variants: [Variant],
                   enum_decls: [EnumDecl], idx_lists: [int]) -> int {
    expect(tokens, pos, 21);
    let name: string = expect_ident(tokens, pos);
    expect(tokens, pos, 52);
    let vs: int = len(variants);
    let mut vc: int = 0;
    if pk(tokens, pos) != 53 {
        let vn: string = expect_ident(tokens, pos);
        let mut vfs: int = len(idx_lists);
        let mut vfc: int = 0;
        if pk(tokens, pos) == 50 {
            advance(pos);
            if pk(tokens, pos) != 51 {
                let vt: int = parse_type(tokens, pos, types);
                push_int(idx_lists, vt);
                vfc = vfc + 1;
                while pk(tokens, pos) == 60 {
                    advance(pos);
                    let vt2: int = parse_type(tokens, pos, types);
                    push_int(idx_lists, vt2);
                    vfc = vfc + 1;
                }
            }
            expect(tokens, pos, 51);
        }
        push_variant(variants, make_variant(vn, vfs, vfc));
        vc = vc + 1;
        while pk(tokens, pos) == 60 {
            advance(pos);
            if pk(tokens, pos) == 53 {
                // trailing comma
            } else {
                let vn2: string = expect_ident(tokens, pos);
                let mut vfs2: int = len(idx_lists);
                let mut vfc2: int = 0;
                if pk(tokens, pos) == 50 {
                    advance(pos);
                    if pk(tokens, pos) != 51 {
                        let vt3: int = parse_type(tokens, pos, types);
                        push_int(idx_lists, vt3);
                        vfc2 = vfc2 + 1;
                        while pk(tokens, pos) == 60 {
                            advance(pos);
                            let vt4: int = parse_type(tokens, pos, types);
                            push_int(idx_lists, vt4);
                            vfc2 = vfc2 + 1;
                        }
                    }
                    expect(tokens, pos, 51);
                }
                push_variant(variants, make_variant(vn2, vfs2, vfc2));
                vc = vc + 1;
            }
        }
    }
    expect(tokens, pos, 53);
    return push_enumdecl(enum_decls, make_enumdecl(name, vs, vc));
}

// ═══════════════════════════════════════════════════════════════
//  Parse program — top-level entry
// ═══════════════════════════════════════════════════════════════

fn parse_program(tokens: [Token], pos: [int],
                 exprs: [Expr], stmts: [Stmt], blocks: [Block],
                 types: [TypeNode], params: [Param],
                 fn_decls: [FnDecl], struct_decls: [StructDecl],
                 fields: [Field], enum_decls: [EnumDecl],
                 variants: [Variant], idx_lists: [int],
                 patterns: [Pattern], match_arms: [MatchArm]) -> unit {
    // Optional: module name;
    if pk(tokens, pos) == 22 {
        advance(pos);
        expect_ident(tokens, pos);
        expect(tokens, pos, 62);
    }

    // Parse declarations until EOF
    while pk(tokens, pos) != 0 {
        let k: int = pk(tokens, pos);
        // Skip pub/pure modifiers (not needed for bootstrap)
        if k == 25 { advance(pos); }
        if k == 26 { advance(pos); }

        let k2: int = pk(tokens, pos);
        if k2 == 10 {
            parse_fn_decl(tokens, pos, exprs, stmts, blocks, types, params, fn_decls, idx_lists, patterns, match_arms);
        } else if k2 == 20 {
            parse_struct_decl(tokens, pos, types, fields, struct_decls);
        } else if k2 == 21 {
            parse_enum_decl(tokens, pos, types, variants, enum_decls, idx_lists);
        } else if k2 == 24 {
            // const decl: const NAME : TYPE = EXPR ;
            advance(pos);
            expect_ident(tokens, pos);
            expect(tokens, pos, 61);
            parse_type(tokens, pos, types);
            expect(tokens, pos, 70);
            parse_expr(tokens, pos, exprs, idx_lists);
            expect(tokens, pos, 62);
        } else if k2 == 28 {
            // impl block: skip for bootstrap
            advance(pos);
            expect_ident(tokens, pos);
            // Skip body
            expect(tokens, pos, 52);
            let mut depth: int = 1;
            while depth > 0 {
                if pk(tokens, pos) == 52 { depth = depth + 1; }
                if pk(tokens, pos) == 53 { depth = depth - 1; }
                if pk(tokens, pos) == 0 {
                    parse_error("unexpected EOF in impl block", tokens, pos[0]);
                }
                advance(pos);
            }
        } else if k2 == 29 {
            // trait block: skip for bootstrap
            advance(pos);
            expect_ident(tokens, pos);
            expect(tokens, pos, 52);
            let mut tdepth: int = 1;
            while tdepth > 0 {
                if pk(tokens, pos) == 52 { tdepth = tdepth + 1; }
                if pk(tokens, pos) == 53 { tdepth = tdepth - 1; }
                if pk(tokens, pos) == 0 {
                    parse_error("unexpected EOF in trait block", tokens, pos[0]);
                }
                advance(pos);
            }
        } else if k2 == 23 {
            // use decl: use a.b.c;
            advance(pos);
            expect_ident(tokens, pos);
            while pk(tokens, pos) == 63 {
                advance(pos);
                expect_ident(tokens, pos);
            }
            expect(tokens, pos, 62);
        } else {
            parse_error("expected declaration", tokens, pos[0]);
        }
    }
}

// ═══════════════════════════════════════════════════════════════
//  Debug: print AST summary
// ═══════════════════════════════════════════════════════════════

fn print_ast_summary(fn_decls: [FnDecl], struct_decls: [StructDecl],
                     enum_decls: [EnumDecl], params: [Param],
                     blocks: [Block], stmts: [Stmt]) -> unit {
    let mut i: int = 0;
    while i < len(struct_decls) {
        let sd: StructDecl = struct_decls[i];
        print_str(str_concat("StructDecl: ", str_concat(sd.name, str_concat(", ", str_concat(int_to_str(sd.field_count), " fields\n")))));
        i = i + 1;
    }
    i = 0;
    while i < len(enum_decls) {
        let ed: EnumDecl = enum_decls[i];
        print_str(str_concat("EnumDecl: ", str_concat(ed.name, str_concat(", ", str_concat(int_to_str(ed.variant_count), " variants\n")))));
        i = i + 1;
    }
    i = 0;
    while i < len(fn_decls) {
        let fd: FnDecl = fn_decls[i];
        let bi: int = fd.body;
        let b: Block = blocks[bi];
        print_str(str_concat("FnDecl: ", str_concat(fd.name, str_concat(", ", str_concat(int_to_str(fd.param_count), str_concat(" params, ", str_concat(int_to_str(b.count), " stmts\n")))))));
        i = i + 1;
    }
}

// ═══════════════════════════════════════════════════════════════
//  Type Checker
//
//  Type IDs:
//    1=int 2=float 3=bool 4=char 5=string 6=unit 7=Map
//    Named types (structs/enums): 100 + index_in_names array
//    Array types: 1000 + element_type_id
//    -1 = error/unknown
// ═══════════════════════════════════════════════════════════════

// Resolve a TypeNode (parser's type representation) to a type ID
fn resolve_type(tn_idx: int, types: [TypeNode], type_names: Map) -> int {
    let tn: TypeNode = types[tn_idx];
    let tag: int = tn.tag;
    if tag == 1 { return 1; }
    if tag == 2 { return 2; }
    if tag == 3 { return 3; }
    if tag == 4 { return 4; }
    if tag == 5 { return 5; }
    if tag == 6 { return 6; }
    if tag == 9 { return 7; }
    // Named type (struct/enum)
    if tag == 7 {
        if map_has(type_names, tn.s1) {
            return 100 + map_get(type_names, tn.s1);
        }
        print_err(str_concat("type error: unknown type '", str_concat(tn.s1, "'\n")));
        return -1;
    }
    // Array type
    if tag == 8 {
        let elem: int = resolve_type(tn.n1, types, type_names);
        if elem < 0 { return -1; }
        return 1000 + elem;
    }
    return -1;
}

fn type_name(tid: int, named_types: [string]) -> string {
    if tid == 1 { return "int"; }
    if tid == 2 { return "float"; }
    if tid == 3 { return "bool"; }
    if tid == 4 { return "char"; }
    if tid == 5 { return "string"; }
    if tid == 6 { return "unit"; }
    if tid == 7 { return "Map"; }
    if tid >= 1000 {
        return str_concat("[", str_concat(type_name(tid - 1000, named_types), "]"));
    }
    if tid >= 100 {
        let ni: int = tid - 100;
        if ni < len(named_types) {
            return named_types[ni];
        }
        return "?named?";
    }
    if tid == -1 { return "?error?"; }
    return "?unknown?";
}

// Function signature storage: parallel arrays
// fn_sig_names[i], fn_sig_param_start[i], fn_sig_param_count[i],
// fn_sig_ret[i], fn_sig_param_types[j] (flattened param types)
//
// We store builtin + user fn signatures in these arrays.

fn tc_error(msg: string) -> unit {
    print_err(str_concat("type error: ", str_concat(msg, "\n")));
}

// Scope stack: array of Maps (each Map is string -> int (type ID))
// Also parallel array for mutability: array of Maps (string -> int, 1=mutable 0=immutable)
fn tc_push_scope(scopes: [Map], mut_scopes: [Map]) -> unit {
    let mut sc: [Map] = scopes;
    let mut ms: [Map] = mut_scopes;
    push(sc, map_new());
    push(ms, map_new());
}

fn tc_pop_scope(scopes: [Map], mut_scopes: [Map]) -> unit {
    let mut sc: [Map] = scopes;
    let mut ms: [Map] = mut_scopes;
    pop(sc);
    pop(ms);
}

fn tc_define(scopes: [Map], mut_scopes: [Map], name: string, tid: int, is_mut: int) -> unit {
    let n: int = len(scopes);
    let top: Map = scopes[n - 1];
    map_set(top, name, tid);
    let mtop: Map = mut_scopes[n - 1];
    map_set(mtop, name, is_mut);
}

fn tc_lookup(scopes: [Map], name: string) -> int {
    let mut i: int = len(scopes) - 1;
    while i >= 0 {
        let sc: Map = scopes[i];
        if map_has(sc, name) {
            return map_get(sc, name);
        }
        i = i - 1;
    }
    return -1;
}

fn tc_is_mutable(mut_scopes: [Map], name: string) -> bool {
    let mut i: int = len(mut_scopes) - 1;
    while i >= 0 {
        let ms: Map = mut_scopes[i];
        if map_has(ms, name) {
            return map_get(ms, name) == 1;
        }
        i = i - 1;
    }
    return false;
}

// ═══════════════════════════════════════════════════════════════
//  Infer expression type — returns type ID
// ═══════════════════════════════════════════════════════════════

fn tc_infer_expr(ei: int, exprs: [Expr], idx_lists: [int],
                 scopes: [Map], mut_scopes: [Map],
                 fn_names: [string], fn_ret: [int], fn_pstart: [int], fn_pcount: [int],
                 fn_ptypes: [int],
                 struct_names: [string], struct_fstart: [int], struct_fcount: [int],
                 sf_names: [string], sf_types: [int],
                 enum_names: [string], enum_vstart: [int], enum_vcount: [int],
                 ev_names: [string], ev_fcount: [int],
                 named_types: [string], type_names: Map) -> int {
    let e: Expr = exprs[ei];
    let tag: int = e.tag;

    // IntLit
    if tag == 1 { return 1; }
    // BoolLit
    if tag == 2 { return 3; }
    // StrLit
    if tag == 3 { return 5; }
    // CharLit
    if tag == 4 { return 4; }
    // FloatLit
    if tag == 14 { return 2; }

    // Ident
    if tag == 5 {
        let tid: int = tc_lookup(scopes, e.s1);
        if tid < 0 {
            // Check if it's a no-data enum variant
            let mut vi: int = 0;
            while vi < len(ev_names) {
                if str_eq(ev_names[vi], e.s1) {
                    if ev_fcount[vi] == 0 {
                        // Find which enum this variant belongs to
                        let mut eidx: int = 0;
                        while eidx < len(enum_names) {
                            let vs: int = enum_vstart[eidx];
                            let vc: int = enum_vcount[eidx];
                            if vi >= vs {
                                if vi < vs + vc {
                                    if map_has(type_names, enum_names[eidx]) {
                                        return 100 + map_get(type_names, enum_names[eidx]);
                                    }
                                }
                            }
                            eidx = eidx + 1;
                        }
                    }
                }
                vi = vi + 1;
            }
            tc_error(str_concat("undefined variable '", str_concat(e.s1, "'")));
        }
        return tid;
    }

    // Binary
    if tag == 6 {
        let lt: int = tc_infer_expr(e.n1, exprs, idx_lists, scopes, mut_scopes,
                        fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                        struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                        enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                        named_types, type_names);
        let rt: int = tc_infer_expr(e.n2, exprs, idx_lists, scopes, mut_scopes,
                        fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                        struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                        enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                        named_types, type_names);
        let op: int = e.n3;
        // Arithmetic: +, -, *, /, %
        if op >= 1 {
            if op <= 5 {
                if lt != rt {
                    tc_error("binary operator type mismatch");
                }
                return lt;
            }
        }
        // Comparison: ==, !=, <, >, <=, >=
        if op >= 6 {
            if op <= 11 {
                return 3;
            }
        }
        // Logical: and, or
        if op == 12 { return 3; }
        if op == 13 { return 3; }
        return lt;
    }

    // Unary
    if tag == 7 {
        let ot: int = tc_infer_expr(e.n1, exprs, idx_lists, scopes, mut_scopes,
                        fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                        struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                        enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                        named_types, type_names);
        if e.n2 == 1 { return ot; }
        if e.n2 == 2 { return 3; }
        return ot;
    }

    // Call
    if tag == 8 {
        return tc_infer_call(ei, exprs, idx_lists, scopes, mut_scopes,
                    fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                    struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                    enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                    named_types, type_names);
    }

    // FieldAccess
    if tag == 9 {
        let obj_t: int = tc_infer_expr(e.n1, exprs, idx_lists, scopes, mut_scopes,
                        fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                        struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                        enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                        named_types, type_names);
        if obj_t >= 100 {
            if obj_t < 1000 {
                let si: int = obj_t - 100;
                // Find struct with this name index
                let mut sdi: int = 0;
                while sdi < len(struct_names) {
                    if map_has(type_names, struct_names[sdi]) {
                        if map_get(type_names, struct_names[sdi]) == si {
                            let fs: int = struct_fstart[sdi];
                            let fc: int = struct_fcount[sdi];
                            let mut fi: int = 0;
                            while fi < fc {
                                if str_eq(sf_names[fs + fi], e.s1) {
                                    return sf_types[fs + fi];
                                }
                                fi = fi + 1;
                            }
                            tc_error(str_concat("no field '", str_concat(e.s1, str_concat("' in struct '", str_concat(struct_names[sdi], "'")))));
                            return -1;
                        }
                    }
                    sdi = sdi + 1;
                }
            }
        }
        tc_error(str_concat("field access on non-struct type for '", str_concat(e.s1, "'")));
        return -1;
    }

    // MethodCall
    if tag == 10 {
        // For bootstrap, method calls not needed (no impl blocks)
        tc_error("method calls not supported in bootstrap");
        return -1;
    }

    // Index
    if tag == 11 {
        let arr_t: int = tc_infer_expr(e.n1, exprs, idx_lists, scopes, mut_scopes,
                        fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                        struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                        enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                        named_types, type_names);
        if arr_t >= 1000 {
            return arr_t - 1000;
        }
        tc_error("indexing non-array type");
        return -1;
    }

    // StructInit
    if tag == 12 {
        if map_has(type_names, e.s1) {
            return 100 + map_get(type_names, e.s1);
        }
        tc_error(str_concat("unknown struct '", str_concat(e.s1, "'")));
        return -1;
    }

    // ArrayLit
    if tag == 13 {
        if e.n2 == 0 {
            return 1000 + 1;
        }
        let first_e: int = idx_lists[e.n1];
        let elem_t: int = tc_infer_expr(first_e, exprs, idx_lists, scopes, mut_scopes,
                        fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                        struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                        enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                        named_types, type_names);
        return 1000 + elem_t;
    }

    tc_error("unknown expression tag");
    return -1;
}

// ═══════════════════════════════════════════════════════════════
//  Infer call expression type
// ═══════════════════════════════════════════════════════════════

fn tc_infer_call(ei: int, exprs: [Expr], idx_lists: [int],
                 scopes: [Map], mut_scopes: [Map],
                 fn_names: [string], fn_ret: [int], fn_pstart: [int], fn_pcount: [int],
                 fn_ptypes: [int],
                 struct_names: [string], struct_fstart: [int], struct_fcount: [int],
                 sf_names: [string], sf_types: [int],
                 enum_names: [string], enum_vstart: [int], enum_vcount: [int],
                 ev_names: [string], ev_fcount: [int],
                 named_types: [string], type_names: Map) -> int {
    let e: Expr = exprs[ei];
    let callee: Expr = exprs[e.n1];
    let arg_start: int = e.n2;
    let arg_count: int = e.n3;

    // Only handle named function calls
    if callee.tag != 5 {
        tc_error("indirect calls not supported");
        return -1;
    }
    let fname: string = callee.s1;

    // Special builtins: len, push, pop, args, exit
    if str_eq(fname, "len") {
        if arg_count == 1 {
            let at: int = tc_infer_expr(idx_lists[arg_start], exprs, idx_lists, scopes, mut_scopes,
                            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                            named_types, type_names);
            if at >= 1000 { return 1; }
            if at == 5 { return 1; }
            tc_error("len() requires array or string argument");
        }
        return 1;
    }

    if str_eq(fname, "push") {
        if arg_count == 2 {
            tc_infer_expr(idx_lists[arg_start], exprs, idx_lists, scopes, mut_scopes,
                fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                named_types, type_names);
            tc_infer_expr(idx_lists[arg_start + 1], exprs, idx_lists, scopes, mut_scopes,
                fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                named_types, type_names);
        }
        return 6;
    }

    if str_eq(fname, "pop") {
        if arg_count == 1 {
            let pop_at: int = tc_infer_expr(idx_lists[arg_start], exprs, idx_lists, scopes, mut_scopes,
                            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                            named_types, type_names);
            if pop_at >= 1000 { return pop_at - 1000; }
        }
        return -1;
    }

    if str_eq(fname, "args") {
        return 1000 + 5;
    }

    if str_eq(fname, "exit") {
        if arg_count == 1 {
            tc_infer_expr(idx_lists[arg_start], exprs, idx_lists, scopes, mut_scopes,
                fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                named_types, type_names);
        }
        return 6;
    }

    // Look up in registered functions
    let mut fi: int = 0;
    while fi < len(fn_names) {
        if str_eq(fn_names[fi], fname) {
            // Check args (infer each one)
            let mut ai: int = 0;
            while ai < arg_count {
                tc_infer_expr(idx_lists[arg_start + ai], exprs, idx_lists, scopes, mut_scopes,
                    fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                    struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                    enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                    named_types, type_names);
                ai = ai + 1;
            }
            return fn_ret[fi];
        }
        fi = fi + 1;
    }

    // Check enum variant constructors
    let mut vi2: int = 0;
    while vi2 < len(ev_names) {
        if str_eq(ev_names[vi2], fname) {
            if ev_fcount[vi2] > 0 {
                // Infer args
                let mut ai2: int = 0;
                while ai2 < arg_count {
                    tc_infer_expr(idx_lists[arg_start + ai2], exprs, idx_lists, scopes, mut_scopes,
                        fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                        struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                        enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                        named_types, type_names);
                    ai2 = ai2 + 1;
                }
                // Find which enum this belongs to
                let mut eidx2: int = 0;
                while eidx2 < len(enum_names) {
                    let evs: int = enum_vstart[eidx2];
                    let evc: int = enum_vcount[eidx2];
                    if vi2 >= evs {
                        if vi2 < evs + evc {
                            if map_has(type_names, enum_names[eidx2]) {
                                return 100 + map_get(type_names, enum_names[eidx2]);
                            }
                        }
                    }
                    eidx2 = eidx2 + 1;
                }
            }
        }
        vi2 = vi2 + 1;
    }

    tc_error(str_concat("undefined function '", str_concat(fname, "'")));
    return -1;
}

// ═══════════════════════════════════════════════════════════════
//  Check statements
// ═══════════════════════════════════════════════════════════════

fn tc_check_stmt(si: int, exprs: [Expr], stmts: [Stmt], blocks: [Block],
                 types: [TypeNode], idx_lists: [int],
                 patterns: [Pattern], match_arms_pool: [MatchArm],
                 scopes: [Map], mut_scopes: [Map],
                 fn_names: [string], fn_ret: [int], fn_pstart: [int], fn_pcount: [int],
                 fn_ptypes: [int],
                 struct_names: [string], struct_fstart: [int], struct_fcount: [int],
                 sf_names: [string], sf_types: [int],
                 enum_names: [string], enum_vstart: [int], enum_vcount: [int],
                 ev_names: [string], ev_fcount: [int],
                 named_types: [string], type_names: Map,
                 cur_ret: int) -> unit {
    let s: Stmt = stmts[si];
    let stag: int = s.tag;

    // Let
    if stag == 1 {
        let tid: int = resolve_type(s.n1, types, type_names);
        tc_infer_expr(s.n2, exprs, idx_lists, scopes, mut_scopes,
            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names);
        tc_define(scopes, mut_scopes, s.s1, tid, s.n3);
    }

    // Assign
    if stag == 2 {
        tc_infer_expr(s.n1, exprs, idx_lists, scopes, mut_scopes,
            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names);
        tc_infer_expr(s.n2, exprs, idx_lists, scopes, mut_scopes,
            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names);
    }

    // Return
    if stag == 3 {
        tc_infer_expr(s.n1, exprs, idx_lists, scopes, mut_scopes,
            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names);
    }

    // If
    if stag == 4 {
        tc_infer_expr(s.n1, exprs, idx_lists, scopes, mut_scopes,
            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names);
        tc_check_block(s.n2, exprs, stmts, blocks, types, idx_lists, patterns, match_arms_pool,
            scopes, mut_scopes, fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names, cur_ret);
        if s.n3 >= 0 {
            tc_check_block(s.n3, exprs, stmts, blocks, types, idx_lists, patterns, match_arms_pool,
                scopes, mut_scopes, fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                named_types, type_names, cur_ret);
        }
        if s.n4 >= 0 {
            tc_check_stmt(s.n4, exprs, stmts, blocks, types, idx_lists, patterns, match_arms_pool,
                scopes, mut_scopes, fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                named_types, type_names, cur_ret);
        }
    }

    // While
    if stag == 5 {
        tc_infer_expr(s.n1, exprs, idx_lists, scopes, mut_scopes,
            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names);
        tc_check_block(s.n2, exprs, stmts, blocks, types, idx_lists, patterns, match_arms_pool,
            scopes, mut_scopes, fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names, cur_ret);
    }

    // For
    if stag == 6 {
        let iter_t: int = tc_infer_expr(s.n1, exprs, idx_lists, scopes, mut_scopes,
            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names);
        tc_push_scope(scopes, mut_scopes);
        if iter_t >= 1000 {
            tc_define(scopes, mut_scopes, s.s1, iter_t - 1000, 0);
        } else {
            tc_define(scopes, mut_scopes, s.s1, 1, 0);
        }
        let fb: Block = blocks[s.n2];
        let mut fsi: int = 0;
        while fsi < fb.count {
            tc_check_stmt(idx_lists[fb.first + fsi], exprs, stmts, blocks, types, idx_lists, patterns, match_arms_pool,
                scopes, mut_scopes, fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                named_types, type_names, cur_ret);
            fsi = fsi + 1;
        }
        tc_pop_scope(scopes, mut_scopes);
    }

    // Match
    if stag == 7 {
        let subj_t: int = tc_infer_expr(s.n1, exprs, idx_lists, scopes, mut_scopes,
            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names);
        let mut mai: int = 0;
        while mai < s.n3 {
            let arm_idx: int = idx_lists[s.n2 + mai];
            let arm: MatchArm = match_arms_pool[arm_idx];
            tc_push_scope(scopes, mut_scopes);
            // Check pattern bindings
            tc_bind_pattern(arm.pat_idx, patterns, idx_lists, scopes, mut_scopes, subj_t,
                enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                named_types, type_names);
            // Check body
            let ab: Block = blocks[arm.body_idx];
            let mut asi: int = 0;
            while asi < ab.count {
                tc_check_stmt(idx_lists[ab.first + asi], exprs, stmts, blocks, types, idx_lists, patterns, match_arms_pool,
                    scopes, mut_scopes, fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
                    struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                    enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                    named_types, type_names, cur_ret);
                asi = asi + 1;
            }
            tc_pop_scope(scopes, mut_scopes);
            mai = mai + 1;
        }
    }

    // ExprStmt
    if stag == 8 {
        tc_infer_expr(s.n1, exprs, idx_lists, scopes, mut_scopes,
            fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names);
    }
}

fn tc_bind_pattern(pi: int, patterns: [Pattern], idx_lists: [int],
                   scopes: [Map], mut_scopes: [Map], subj_t: int,
                   enum_names: [string], enum_vstart: [int], enum_vcount: [int],
                   ev_names: [string], ev_fcount: [int],
                   named_types: [string], type_names: Map) -> unit {
    let p: Pattern = patterns[pi];
    // Binding
    if p.tag == 5 {
        // Check if it's actually a no-data enum variant name
        let mut is_variant: bool = false;
        let mut vi3: int = 0;
        while vi3 < len(ev_names) {
            if str_eq(ev_names[vi3], p.s1) {
                is_variant = true;
            }
            vi3 = vi3 + 1;
        }
        if not is_variant {
            tc_define(scopes, mut_scopes, p.s1, subj_t, 0);
        }
    }
    // Variant pattern
    if p.tag == 6 {
        let mut spi: int = 0;
        while spi < p.n2 {
            let sub_pi: int = idx_lists[p.n1 + spi];
            let sub: Pattern = patterns[sub_pi];
            if sub.tag == 5 {
                tc_define(scopes, mut_scopes, sub.s1, 1, 0);
            }
            spi = spi + 1;
        }
    }
    // Wildcard, literal patterns: no binding needed, fall through
}

fn tc_check_block(bi: int, exprs: [Expr], stmts: [Stmt], blocks: [Block],
                  types: [TypeNode], idx_lists: [int],
                  patterns: [Pattern], match_arms_pool: [MatchArm],
                  scopes: [Map], mut_scopes: [Map],
                  fn_names: [string], fn_ret: [int], fn_pstart: [int], fn_pcount: [int],
                  fn_ptypes: [int],
                  struct_names: [string], struct_fstart: [int], struct_fcount: [int],
                  sf_names: [string], sf_types: [int],
                  enum_names: [string], enum_vstart: [int], enum_vcount: [int],
                  ev_names: [string], ev_fcount: [int],
                  named_types: [string], type_names: Map,
                  cur_ret: int) -> unit {
    tc_push_scope(scopes, mut_scopes);
    let b: Block = blocks[bi];
    let mut bsi: int = 0;
    while bsi < b.count {
        tc_check_stmt(idx_lists[b.first + bsi], exprs, stmts, blocks, types, idx_lists, patterns, match_arms_pool,
            scopes, mut_scopes, fn_names, fn_ret, fn_pstart, fn_pcount, fn_ptypes,
            struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
            enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
            named_types, type_names, cur_ret);
        bsi = bsi + 1;
    }
    tc_pop_scope(scopes, mut_scopes);
}

// ═══════════════════════════════════════════════════════════════
//  Type checker main entry — two-pass
// ═══════════════════════════════════════════════════════════════

fn typecheck(fn_decls: [FnDecl], struct_decls: [StructDecl], enum_decls: [EnumDecl],
             params: [Param], blocks: [Block], stmts: [Stmt], exprs: [Expr],
             types: [TypeNode], fields: [Field], variants: [Variant],
             idx_lists: [int], patterns: [Pattern], match_arms_pool: [MatchArm]) -> unit {
    // === Pass 1: Register all type names, then fn signatures ===

    // Named type registry: type_names maps name -> index, named_types[i] is the name
    let type_names: Map = map_new();
    let mut named_types: [string] = [""];
    pop(named_types);

    // Register struct names
    let mut si2: int = 0;
    while si2 < len(struct_decls) {
        let sd2: StructDecl = struct_decls[si2];
        let ni: int = len(named_types);
        let mut nt: [string] = named_types;
        push(nt, sd2.name);
        map_set(type_names, sd2.name, ni);
        si2 = si2 + 1;
    }

    // Register enum names
    let mut ei2: int = 0;
    while ei2 < len(enum_decls) {
        let ed2: EnumDecl = enum_decls[ei2];
        let ni2: int = len(named_types);
        let mut nt2: [string] = named_types;
        push(nt2, ed2.name);
        map_set(type_names, ed2.name, ni2);
        ei2 = ei2 + 1;
    }

    // Build struct field info: parallel arrays
    let mut struct_names: [string] = [""];
    pop(struct_names);
    let mut struct_fstart: [int] = [0];
    pop(struct_fstart);
    let mut struct_fcount: [int] = [0];
    pop(struct_fcount);
    let mut sf_names: [string] = [""];
    pop(sf_names);
    let mut sf_types: [int] = [0];
    pop(sf_types);

    let mut si3: int = 0;
    while si3 < len(struct_decls) {
        let sd3: StructDecl = struct_decls[si3];
        push(struct_names, sd3.name);
        push(struct_fstart, len(sf_names));
        let mut fc2: int = 0;
        let mut fi2: int = 0;
        while fi2 < sd3.field_count {
            let f2: Field = fields[sd3.field_start + fi2];
            push(sf_names, f2.name);
            let ft: int = resolve_type(f2.type_idx, types, type_names);
            push(sf_types, ft);
            fc2 = fc2 + 1;
            fi2 = fi2 + 1;
        }
        push(struct_fcount, fc2);
        si3 = si3 + 1;
    }

    // Build enum variant info
    let mut enum_names: [string] = [""];
    pop(enum_names);
    let mut enum_vstart: [int] = [0];
    pop(enum_vstart);
    let mut enum_vcount: [int] = [0];
    pop(enum_vcount);
    let mut ev_names: [string] = [""];
    pop(ev_names);
    let mut ev_fcount: [int] = [0];
    pop(ev_fcount);

    let mut ei3: int = 0;
    while ei3 < len(enum_decls) {
        let ed3: EnumDecl = enum_decls[ei3];
        push(enum_names, ed3.name);
        push(enum_vstart, len(ev_names));
        let mut vc2: int = 0;
        let mut vi4: int = 0;
        while vi4 < ed3.variant_count {
            let v4: Variant = variants[ed3.variant_start + vi4];
            push(ev_names, v4.name);
            push(ev_fcount, v4.field_count);
            vc2 = vc2 + 1;
            vi4 = vi4 + 1;
        }
        push(enum_vcount, vc2);
        ei3 = ei3 + 1;
    }

    // Build function signatures
    let mut fn_names: [string] = [""];
    pop(fn_names);
    let mut fn_ret_types: [int] = [0];
    pop(fn_ret_types);
    let mut fn_pstart: [int] = [0];
    pop(fn_pstart);
    let mut fn_pcount: [int] = [0];
    pop(fn_pcount);
    let mut fn_ptypes: [int] = [0];
    pop(fn_ptypes);

    // Register builtins
    // print_int(int) -> unit
    push(fn_names, "print_int"); push(fn_ret_types, 6); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 1);
    push(fn_names, "print_float"); push(fn_ret_types, 6); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 2);
    push(fn_names, "print_bool"); push(fn_ret_types, 6); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 3);
    push(fn_names, "print_str"); push(fn_ret_types, 6); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 5);
    push(fn_names, "print_char"); push(fn_ret_types, 6); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 4);
    push(fn_names, "print_err"); push(fn_ret_types, 6); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 5);
    // string ops
    push(fn_names, "str_len"); push(fn_ret_types, 1); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 5);
    push(fn_names, "str_concat"); push(fn_ret_types, 5); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 2); push(fn_ptypes, 5); push(fn_ptypes, 5);
    push(fn_names, "str_eq"); push(fn_ret_types, 3); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 2); push(fn_ptypes, 5); push(fn_ptypes, 5);
    push(fn_names, "str_charAt"); push(fn_ret_types, 4); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 2); push(fn_ptypes, 5); push(fn_ptypes, 1);
    push(fn_names, "str_sub"); push(fn_ret_types, 5); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 3); push(fn_ptypes, 5); push(fn_ptypes, 1); push(fn_ptypes, 1);
    push(fn_names, "str_from_char"); push(fn_ret_types, 5); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 4);
    // type casts
    push(fn_names, "char_to_int"); push(fn_ret_types, 1); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 4);
    push(fn_names, "int_to_char"); push(fn_ret_types, 4); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 1);
    push(fn_names, "int_to_float"); push(fn_ret_types, 2); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 1);
    push(fn_names, "float_to_int"); push(fn_ret_types, 1); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 2);
    push(fn_names, "int_to_str"); push(fn_ret_types, 5); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 1);
    push(fn_names, "str_to_int"); push(fn_ret_types, 1); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 5);
    // char classification
    push(fn_names, "char_is_alpha"); push(fn_ret_types, 3); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 4);
    push(fn_names, "char_is_digit"); push(fn_ret_types, 3); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 4);
    push(fn_names, "char_is_whitespace"); push(fn_ret_types, 3); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 4);
    // file I/O
    push(fn_names, "file_read"); push(fn_ret_types, 5); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 1); push(fn_ptypes, 5);
    push(fn_names, "file_write"); push(fn_ret_types, 3); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 2); push(fn_ptypes, 5); push(fn_ptypes, 5);
    // map operations
    push(fn_names, "map_new"); push(fn_ret_types, 7); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 0);
    push(fn_names, "map_set"); push(fn_ret_types, 6); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 3); push(fn_ptypes, 7); push(fn_ptypes, 5); push(fn_ptypes, 1);
    push(fn_names, "map_get"); push(fn_ret_types, 1); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 2); push(fn_ptypes, 7); push(fn_ptypes, 5);
    push(fn_names, "map_has"); push(fn_ret_types, 3); push(fn_pstart, len(fn_ptypes)); push(fn_pcount, 2); push(fn_ptypes, 7); push(fn_ptypes, 5);

    // Register user-defined functions
    let mut fi3: int = 0;
    while fi3 < len(fn_decls) {
        let fd3: FnDecl = fn_decls[fi3];
        push(fn_names, fd3.name);
        let ret_t: int = resolve_type(fd3.ret_type, types, type_names);
        push(fn_ret_types, ret_t);
        push(fn_pstart, len(fn_ptypes));
        push(fn_pcount, fd3.param_count);
        let mut pi3: int = 0;
        while pi3 < fd3.param_count {
            let p3: Param = params[fd3.param_start + pi3];
            let pt: int = resolve_type(p3.type_idx, types, type_names);
            push(fn_ptypes, pt);
            pi3 = pi3 + 1;
        }
        fi3 = fi3 + 1;
    }

    // === Pass 2: Check function bodies ===
    let mut scopes: [Map] = [map_new()];
    pop(scopes);
    let mut mut_scopes: [Map] = [map_new()];
    pop(mut_scopes);

    let mut fi4: int = 0;
    while fi4 < len(fn_decls) {
        let fd4: FnDecl = fn_decls[fi4];
        let ret_t2: int = resolve_type(fd4.ret_type, types, type_names);

        // Push function scope and define params
        tc_push_scope(scopes, mut_scopes);
        let mut pi4: int = 0;
        while pi4 < fd4.param_count {
            let p4: Param = params[fd4.param_start + pi4];
            let pt2: int = resolve_type(p4.type_idx, types, type_names);
            tc_define(scopes, mut_scopes, p4.name, pt2, 0);
            pi4 = pi4 + 1;
        }

        // Check body
        let fb2: Block = blocks[fd4.body];
        let mut bsi2: int = 0;
        while bsi2 < fb2.count {
            tc_check_stmt(idx_lists[fb2.first + bsi2], exprs, stmts, blocks, types, idx_lists, patterns, match_arms_pool,
                scopes, mut_scopes, fn_names, fn_ret_types, fn_pstart, fn_pcount, fn_ptypes,
                struct_names, struct_fstart, struct_fcount, sf_names, sf_types,
                enum_names, enum_vstart, enum_vcount, ev_names, ev_fcount,
                named_types, type_names, ret_t2);
            bsi2 = bsi2 + 1;
        }

        tc_pop_scope(scopes, mut_scopes);
        fi4 = fi4 + 1;
    }
}

// ═══════════════════════════════════════════════════════════════
//  Code Generation — LLVM IR Emission
// ═══════════════════════════════════════════════════════════════

// ── Output helpers ──

fn sa(buf: [string], line: string) -> unit {
    let mut b: [string] = buf;
    b[0] = str_concat(b[0], str_concat(line, "\n"));
}

fn si(buf: [string], line: string) -> unit {
    let mut b: [string] = buf;
    b[0] = str_concat(b[0], str_concat("  ", str_concat(line, "\n")));
}

fn cg_fresh(c: [int], prefix: string) -> string {
    let mut cc: [int] = c;
    let n: int = cc[0];
    cc[0] = n + 1;
    return str_concat(prefix, int_to_str(n));
}

// Type ID to LLVM type string
fn cg_type(tid: int, nt: [string]) -> string {
    if tid == 1 { return "i64"; }
    if tid == 2 { return "double"; }
    if tid == 3 { return "i1"; }
    if tid == 4 { return "i8"; }
    if tid == 5 { return "ptr"; }
    if tid == 6 { return "void"; }
    if tid == 7 { return "ptr"; }
    if tid >= 1000 { return "ptr"; }
    if tid >= 100 {
        let ni: int = tid - 100;
        if ni < len(nt) {
            return str_concat("%", nt[ni]);
        }
    }
    return "i64";
}

fn cg_is_agg(ty: string) -> bool {
    if str_len(ty) == 0 { return false; }
    return str_charAt(ty, 0) == '%';
}

// ── LLVM string escaping ──

fn cg_esc_char(c: int) -> string {
    if c == 10 { return "\\0A"; }
    if c == 9 { return "\\09"; }
    if c == 13 { return "\\0D"; }
    if c == 92 { return "\\5C"; }
    if c == 34 { return "\\22"; }
    if c == 0 { return "\\00"; }
    return str_from_char(int_to_char(c));
}

fn cg_escape(s: string) -> string {
    let sn: int = str_len(s);
    let mut res: string = "";
    let mut ci: int = 0;
    while ci < sn {
        res = str_concat(res, cg_esc_char(char_to_int(str_charAt(s, ci))));
        ci = ci + 1;
    }
    return res;
}

// ── Variable scope management ──

fn cg_push_scope(scopes: [Map]) -> unit {
    let mut s: [Map] = scopes;
    push(s, map_new());
}

fn cg_pop_scope(scopes: [Map]) -> unit {
    let mut s: [Map] = scopes;
    pop(s);
}

fn cg_def_var(scopes: [Map], ptrs: [string], tys: [string], tids: [int],
              name: string, pn: string, ty: string, tid: int) -> unit {
    let mut p: [string] = ptrs;
    let mut t: [string] = tys;
    let mut d: [int] = tids;
    let idx: int = len(ptrs);
    push(p, pn);
    push(t, ty);
    push(d, tid);
    let sn: int = len(scopes);
    let top: Map = scopes[sn - 1];
    map_set(top, name, idx);
}

fn cg_var_ptr(scopes: [Map], ptrs: [string], name: string) -> string {
    let mut vi: int = len(scopes) - 1;
    while vi >= 0 {
        let sc: Map = scopes[vi];
        if map_has(sc, name) { return ptrs[map_get(sc, name)]; }
        vi = vi - 1;
    }
    return "?ptr?";
}

fn cg_var_ty(scopes: [Map], tys: [string], name: string) -> string {
    let mut vi: int = len(scopes) - 1;
    while vi >= 0 {
        let sc: Map = scopes[vi];
        if map_has(sc, name) { return tys[map_get(sc, name)]; }
        vi = vi - 1;
    }
    return "i64";
}

fn cg_var_tid(scopes: [Map], tids: [int], name: string) -> int {
    let mut vi: int = len(scopes) - 1;
    while vi >= 0 {
        let sc: Map = scopes[vi];
        if map_has(sc, name) { return tids[map_get(sc, name)]; }
        vi = vi - 1;
    }
    return 1;
}

// ── String constant emission ──

fn cg_add_str(globals: [string], sct: [int], val: string) -> string {
    let name: string = cg_fresh(sct, "@.str.");
    let escaped: string = cg_escape(val);
    let blen: int = str_len(val) + 1;
    sa(globals, str_concat(name, str_concat(" = private unnamed_addr constant [",
        str_concat(int_to_str(blen), str_concat(" x i8] c\"",
        str_concat(escaped, "\\00\""))))));
    return name;
}

// ── LLVM type size in bytes ──

fn cg_sizeof(ty: string, struct_decls: [StructDecl], fields: [Field],
    types: [TypeNode], tn: Map, nt: [string]) -> int {
    if str_eq(ty, "i64") { return 8; }
    if str_eq(ty, "double") { return 8; }
    if str_eq(ty, "i1") { return 1; }
    if str_eq(ty, "i8") { return 1; }
    if str_eq(ty, "i32") { return 4; }
    if str_eq(ty, "ptr") { return 8; }
    if str_charAt(ty, 0) == '%' {
        let sz_name: string = str_sub(ty, 1, str_len(ty) - 1);
        let mut sz_i: int = 0;
        while sz_i < len(struct_decls) {
            let sz_sd: StructDecl = struct_decls[sz_i];
            if str_eq(sz_sd.name, sz_name) {
                let mut sz_total: int = 0;
                let mut sz_fi: int = 0;
                while sz_fi < sz_sd.field_count {
                    let sz_f: Field = fields[sz_sd.field_start + sz_fi];
                    let sz_ft: int = resolve_type(sz_f.type_idx, types, tn);
                    let sz_fty: string = cg_type(sz_ft, nt);
                    sz_total = sz_total + cg_sizeof(sz_fty, struct_decls, fields, types, tn, nt);
                    sz_fi = sz_fi + 1;
                }
                return sz_total;
            }
            sz_i = sz_i + 1;
        }
    }
    return 8;
}

// ── Expression type inference (LLVM type string) ──

fn cg_expr_ty(ei: int, exprs: [Expr], idx_lists: [int],
    scopes: [Map], vtys: [string], vtids: [int],
    arr_map: Map, arr_etypes: [string],
    fn_ret_map: Map, nt: [string], tn: Map,
    struct_decls: [StructDecl], fields: [Field], types: [TypeNode],
    enum_decls: [EnumDecl], variants: [Variant]) -> string {
    let e: Expr = exprs[ei];
    if e.tag == 1 { return "i64"; }
    if e.tag == 2 { return "i1"; }
    if e.tag == 3 { return "ptr"; }
    if e.tag == 4 { return "i8"; }
    if e.tag == 14 { return "double"; }
    if e.tag == 5 { return cg_var_ty(scopes, vtys, e.s1); }
    if e.tag == 6 {
        let op: int = e.n3;
        if op >= 6 { return "i1"; }
        return cg_expr_ty(e.n1, exprs, idx_lists, scopes, vtys, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types,
            enum_decls, variants);
    }
    if e.tag == 7 {
        if e.n2 == 2 { return "i1"; }
        return cg_expr_ty(e.n1, exprs, idx_lists, scopes, vtys, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types,
            enum_decls, variants);
    }
    if e.tag == 8 {
        let callee: Expr = exprs[e.n1];
        if callee.tag == 5 {
            let cfn: string = callee.s1;
            if str_eq(cfn, "len") { return "i64"; }
            if str_eq(cfn, "str_len") { return "i64"; }
            if str_eq(cfn, "push") { return "void"; }
            if str_eq(cfn, "pop") {
                if e.n3 > 0 {
                    let arr_e: Expr = exprs[idx_lists[e.n2]];
                    if arr_e.tag == 5 {
                        if map_has(arr_map, arr_e.s1) {
                            return arr_etypes[map_get(arr_map, arr_e.s1)];
                        }
                    }
                }
                return "i64";
            }
            if str_eq(cfn, "args") { return "ptr"; }
            if str_eq(cfn, "exit") { return "void"; }
            if map_has(fn_ret_map, cfn) {
                return cg_type(map_get(fn_ret_map, cfn), nt);
            }
            let et_en: string = cg_find_enum(cfn, enum_decls, variants);
            if str_len(et_en) > 0 {
                return str_concat("%", et_en);
            }
        }
        return "i64";
    }
    if e.tag == 9 {
        let obj_tid: int = cg_expr_tid(e.n1, exprs, idx_lists, scopes, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn,
            struct_decls, fields, types);
        if obj_tid >= 100 {
            if obj_tid < 1000 {
                let sni: int = obj_tid - 100;
                let mut sdi: int = 0;
                while sdi < len(struct_decls) {
                    let sd: StructDecl = struct_decls[sdi];
                    if map_has(tn, sd.name) {
                        if map_get(tn, sd.name) == sni {
                            let mut fi: int = 0;
                            while fi < sd.field_count {
                                let f: Field = fields[sd.field_start + fi];
                                if str_eq(f.name, e.s1) {
                                    let ft: int = resolve_type(f.type_idx, types, tn);
                                    return cg_type(ft, nt);
                                }
                                fi = fi + 1;
                            }
                        }
                    }
                    sdi = sdi + 1;
                }
            }
        }
        return "i64";
    }
    if e.tag == 11 {
        let arr_e2: Expr = exprs[e.n1];
        if arr_e2.tag == 5 {
            if map_has(arr_map, arr_e2.s1) {
                return arr_etypes[map_get(arr_map, arr_e2.s1)];
            }
        }
        return "i64";
    }
    if e.tag == 12 { return str_concat("%", e.s1); }
    if e.tag == 13 { return "{{ ptr, i64, i64 }}"; }
    return "i64";
}

// ── Expression type ID inference ──

fn cg_expr_tid(ei: int, exprs: [Expr], idx_lists: [int],
    scopes: [Map], vtids: [int],
    arr_map: Map, arr_etypes: [string],
    fn_ret_map: Map, nt: [string], tn: Map,
    struct_decls: [StructDecl], fields: [Field], types: [TypeNode]) -> int {
    let e: Expr = exprs[ei];
    if e.tag == 1 { return 1; }
    if e.tag == 2 { return 3; }
    if e.tag == 3 { return 5; }
    if e.tag == 4 { return 4; }
    if e.tag == 14 { return 2; }
    if e.tag == 5 { return cg_var_tid(scopes, vtids, e.s1); }
    if e.tag == 6 {
        if e.n3 >= 6 { return 3; }
        return cg_expr_tid(e.n1, exprs, idx_lists, scopes, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types);
    }
    if e.tag == 7 {
        if e.n2 == 2 { return 3; }
        return cg_expr_tid(e.n1, exprs, idx_lists, scopes, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types);
    }
    if e.tag == 8 {
        let callee2: Expr = exprs[e.n1];
        if callee2.tag == 5 {
            let cfn2: string = callee2.s1;
            if str_eq(cfn2, "len") { return 1; }
            if str_eq(cfn2, "push") { return 6; }
            if str_eq(cfn2, "pop") {
                if e.n3 > 0 {
                    let parg: int = cg_expr_tid(idx_lists[e.n2], exprs, idx_lists,
                        scopes, vtids, arr_map, arr_etypes, fn_ret_map, nt, tn,
                        struct_decls, fields, types);
                    if parg >= 1000 { return parg - 1000; }
                }
                return 1;
            }
            if str_eq(cfn2, "args") { return 1005; }
            if str_eq(cfn2, "exit") { return 6; }
            if map_has(fn_ret_map, cfn2) { return map_get(fn_ret_map, cfn2); }
        }
        return 1;
    }
    if e.tag == 9 {
        let obj_t: int = cg_expr_tid(e.n1, exprs, idx_lists, scopes, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types);
        if obj_t >= 100 {
            if obj_t < 1000 {
                let sni2: int = obj_t - 100;
                let mut sdi2: int = 0;
                while sdi2 < len(struct_decls) {
                    let sd2: StructDecl = struct_decls[sdi2];
                    if map_has(tn, sd2.name) {
                        if map_get(tn, sd2.name) == sni2 {
                            let mut fi2: int = 0;
                            while fi2 < sd2.field_count {
                                let f2: Field = fields[sd2.field_start + fi2];
                                if str_eq(f2.name, e.s1) {
                                    return resolve_type(f2.type_idx, types, tn);
                                }
                                fi2 = fi2 + 1;
                            }
                        }
                    }
                    sdi2 = sdi2 + 1;
                }
            }
        }
        return 1;
    }
    if e.tag == 11 {
        let arrt: int = cg_expr_tid(e.n1, exprs, idx_lists, scopes, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types);
        if arrt >= 1000 { return arrt - 1000; }
        return 1;
    }
    if e.tag == 12 {
        if map_has(tn, e.s1) { return 100 + map_get(tn, e.s1); }
        return 1;
    }
    if e.tag == 13 {
        if e.n2 == 0 { return 1001; }
        let fst: int = cg_expr_tid(idx_lists[e.n1], exprs, idx_lists,
            scopes, vtids, arr_map, arr_etypes, fn_ret_map, nt, tn,
            struct_decls, fields, types);
        return 1000 + fst;
    }
    return 1;
}

// ── Codegen helpers ──

fn cg_binop(op: int, is_f: bool, ty: string,
            t: string, l: string, r: string) -> string {
    let lr: string = str_concat(l, str_concat(", ", r));
    let tlr: string = str_concat(ty, str_concat(" ", lr));
    let dlr: string = str_concat("double ", lr);
    if op == 1 {
        if is_f { return str_concat(t, str_concat(" = fadd ", dlr)); }
        return str_concat(t, str_concat(" = add ", tlr));
    }
    if op == 2 {
        if is_f { return str_concat(t, str_concat(" = fsub ", dlr)); }
        return str_concat(t, str_concat(" = sub ", tlr));
    }
    if op == 3 {
        if is_f { return str_concat(t, str_concat(" = fmul ", dlr)); }
        return str_concat(t, str_concat(" = mul ", tlr));
    }
    if op == 4 {
        if is_f { return str_concat(t, str_concat(" = fdiv ", dlr)); }
        return str_concat(t, str_concat(" = sdiv ", tlr));
    }
    if op == 5 {
        if is_f { return str_concat(t, str_concat(" = frem ", dlr)); }
        return str_concat(t, str_concat(" = srem ", tlr));
    }
    if op == 6 {
        if is_f { return str_concat(t, str_concat(" = fcmp oeq ", dlr)); }
        return str_concat(t, str_concat(" = icmp eq ", tlr));
    }
    if op == 7 {
        if is_f { return str_concat(t, str_concat(" = fcmp one ", dlr)); }
        return str_concat(t, str_concat(" = icmp ne ", tlr));
    }
    if op == 8 {
        if is_f { return str_concat(t, str_concat(" = fcmp olt ", dlr)); }
        return str_concat(t, str_concat(" = icmp slt ", tlr));
    }
    if op == 9 {
        if is_f { return str_concat(t, str_concat(" = fcmp ogt ", dlr)); }
        return str_concat(t, str_concat(" = icmp sgt ", tlr));
    }
    if op == 10 {
        if is_f { return str_concat(t, str_concat(" = fcmp ole ", dlr)); }
        return str_concat(t, str_concat(" = icmp sle ", tlr));
    }
    if op == 11 {
        if is_f { return str_concat(t, str_concat(" = fcmp oge ", dlr)); }
        return str_concat(t, str_concat(" = icmp sge ", tlr));
    }
    if op == 12 { return str_concat(t, str_concat(" = and i1 ", lr)); }
    if op == 13 { return str_concat(t, str_concat(" = or i1 ", lr)); }
    return "";
}

fn cg_sname(ei: int, exprs: [Expr], idx_lists: [int],
    scopes: [Map], vtids: [int],
    arr_map: Map, arr_etypes: [string],
    fn_ret_map: Map, nt: [string], tn: Map,
    struct_decls: [StructDecl], fields: [Field], types: [TypeNode]) -> string {
    let sn_tid: int = cg_expr_tid(ei, exprs, idx_lists, scopes, vtids,
        arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types);
    if sn_tid >= 100 {
        if sn_tid < 1000 { return nt[sn_tid - 100]; }
    }
    return "";
}

fn cg_field_idx(sname: string, fname: string,
    struct_decls: [StructDecl], fields: [Field]) -> int {
    let mut fi_i: int = 0;
    while fi_i < len(struct_decls) {
        let fi_sd: StructDecl = struct_decls[fi_i];
        if str_eq(fi_sd.name, sname) {
            let mut fi_j: int = 0;
            while fi_j < fi_sd.field_count {
                if str_eq(fields[fi_sd.field_start + fi_j].name, fname) { return fi_j; }
                fi_j = fi_j + 1;
            }
        }
        fi_i = fi_i + 1;
    }
    return 0;
}

fn cg_field_ty(sname: string, fname: string,
    struct_decls: [StructDecl], fields: [Field],
    types: [TypeNode], tn: Map, nt: [string]) -> string {
    let mut ft_i: int = 0;
    while ft_i < len(struct_decls) {
        let ft_sd: StructDecl = struct_decls[ft_i];
        if str_eq(ft_sd.name, sname) {
            let mut ft_j: int = 0;
            while ft_j < ft_sd.field_count {
                let ft_f: Field = fields[ft_sd.field_start + ft_j];
                if str_eq(ft_f.name, fname) {
                    return cg_type(resolve_type(ft_f.type_idx, types, tn), nt);
                }
                ft_j = ft_j + 1;
            }
        }
        ft_i = ft_i + 1;
    }
    return "i64";
}

fn cg_find_enum(vname: string, enum_decls: [EnumDecl],
    variants: [Variant]) -> string {
    let mut fe_i: int = 0;
    while fe_i < len(enum_decls) {
        let fe_ed: EnumDecl = enum_decls[fe_i];
        let mut fe_j: int = 0;
        while fe_j < fe_ed.variant_count {
            if str_eq(variants[fe_ed.variant_start + fe_j].name, vname) {
                return fe_ed.name;
            }
            fe_j = fe_j + 1;
        }
        fe_i = fe_i + 1;
    }
    return "";
}

fn cg_variant_tag(vname: string, enum_decls: [EnumDecl],
    variants: [Variant]) -> int {
    let mut vt_i: int = 0;
    while vt_i < len(enum_decls) {
        let vt_ed: EnumDecl = enum_decls[vt_i];
        let mut vt_j: int = 0;
        while vt_j < vt_ed.variant_count {
            if str_eq(variants[vt_ed.variant_start + vt_j].name, vname) {
                return vt_j;
            }
            vt_j = vt_j + 1;
        }
        vt_i = vt_i + 1;
    }
    return 0;
}

fn cg_enum_payload(ename: string, enum_decls: [EnumDecl],
    variants: [Variant], idx_lists: [int],
    struct_decls: [StructDecl], fields: [Field],
    types: [TypeNode], tn: Map, nt: [string]) -> int {
    let mut ep_max: int = 0;
    let mut ep_i: int = 0;
    while ep_i < len(enum_decls) {
        let ep_ed: EnumDecl = enum_decls[ep_i];
        if str_eq(ep_ed.name, ename) {
            let mut ep_j: int = 0;
            while ep_j < ep_ed.variant_count {
                let ep_v: Variant = variants[ep_ed.variant_start + ep_j];
                let mut ep_sz: int = 0;
                let mut ep_k: int = 0;
                while ep_k < ep_v.field_count {
                    let ep_tid: int = resolve_type(idx_lists[ep_v.field_start + ep_k], types, tn);
                    ep_sz = ep_sz + cg_sizeof(cg_type(ep_tid, nt), struct_decls, fields, types, tn, nt);
                    ep_k = ep_k + 1;
                }
                if ep_sz > ep_max { ep_max = ep_sz; }
                ep_j = ep_j + 1;
            }
        }
        ep_i = ep_i + 1;
    }
    return ep_max;
}

fn cg_is_enum(tid: int, nt: [string], enum_decls: [EnumDecl]) -> bool {
    if tid < 100 { return false; }
    if tid >= 1000 { return false; }
    let ie_name: string = nt[tid - 100];
    let mut ie_i: int = 0;
    while ie_i < len(enum_decls) {
        if str_eq(enum_decls[ie_i].name, ie_name) { return true; }
        ie_i = ie_i + 1;
    }
    return false;
}

// Return alloca pointer for lvalue expressions
fn cg_expr_ptr(ei: int, exprs: [Expr], idx_lists: [int],
    body: [string], globals: [string],
    tc: [int], lc: [int], sc: [int],
    scopes: [Map], vptrs: [string], vtys: [string], vtids: [int],
    arr_map: Map, arr_etypes: [string],
    struct_decls: [StructDecl], fields: [Field], types: [TypeNode],
    enum_decls: [EnumDecl], variants: [Variant],
    fn_ret_map: Map, nt: [string], tn: Map,
    term: [int]) -> string {
    let epe: Expr = exprs[ei];
    if epe.tag == 5 { return cg_var_ptr(scopes, vptrs, epe.s1); }
    return cg_expr(ei, exprs, idx_lists, body, globals,
        tc, lc, sc, scopes, vptrs, vtys, vtids,
        arr_map, arr_etypes, struct_decls, fields, types,
        enum_decls, variants, fn_ret_map, nt, tn, term);
}

// ── Expression emission ──

fn cg_expr(ei: int, exprs: [Expr], idx_lists: [int],
    body: [string], globals: [string],
    tc: [int], lc: [int], sc: [int],
    scopes: [Map], vptrs: [string], vtys: [string], vtids: [int],
    arr_map: Map, arr_etypes: [string],
    struct_decls: [StructDecl], fields: [Field], types: [TypeNode],
    enum_decls: [EnumDecl], variants: [Variant],
    fn_ret_map: Map, nt: [string], tn: Map,
    term: [int]) -> string {
    let e: Expr = exprs[ei];
    // IntLit
    if e.tag == 1 { return int_to_str(e.n1); }
    // BoolLit
    if e.tag == 2 {
        if e.n1 == 1 { return "true"; }
        return "false";
    }
    // StrLit
    if e.tag == 3 { return cg_add_str(globals, sc, e.s1); }
    // CharLit
    if e.tag == 4 { return int_to_str(e.n1); }
    // FloatLit
    if e.tag == 14 { return e.s1; }
    // Ident
    if e.tag == 5 {
        let id_ty: string = cg_var_ty(scopes, vtys, e.s1);
        if str_eq(id_ty, "{{ ptr, i64, i64 }}") {
            return cg_var_ptr(scopes, vptrs, e.s1);
        }
        let id_t: string = cg_fresh(tc, "%t");
        si(body, str_concat(id_t, str_concat(" = load ", str_concat(id_ty,
            str_concat(", ptr ", cg_var_ptr(scopes, vptrs, e.s1))))));
        return id_t;
    }
    // Binary
    if e.tag == 6 {
        let bl: string = cg_expr(e.n1, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        let br: string = cg_expr(e.n2, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        let bt: string = cg_fresh(tc, "%t");
        let blt: string = cg_expr_ty(e.n1, exprs, idx_lists, scopes, vtys, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types,
            enum_decls, variants);
        si(body, cg_binop(e.n3, str_eq(blt, "double"), blt, bt, bl, br));
        return bt;
    }
    // Unary
    if e.tag == 7 {
        let uv: string = cg_expr(e.n1, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        let ut: string = cg_fresh(tc, "%t");
        if e.n2 == 1 {
            let uty: string = cg_expr_ty(e.n1, exprs, idx_lists, scopes, vtys, vtids,
                arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types,
                enum_decls, variants);
            if str_eq(uty, "double") {
                si(body, str_concat(ut, str_concat(" = fneg double ", uv)));
            } else {
                si(body, str_concat(ut, str_concat(" = sub i64 0, ", uv)));
            }
        }
        if e.n2 == 2 {
            si(body, str_concat(ut, str_concat(" = xor i1 ", str_concat(uv, ", true"))));
        }
        return ut;
    }
    // Call
    if e.tag == 8 {
        let callee_e: Expr = exprs[e.n1];
        if callee_e.tag == 5 {
            let cfn: string = callee_e.s1;
            // len(arr)
            if str_eq(cfn, "len") {
                let cl_ap: string = cg_expr_ptr(idx_lists[e.n2], exprs, idx_lists,
                    body, globals, tc, lc, sc, scopes, vptrs, vtys, vtids,
                    arr_map, arr_etypes, struct_decls, fields, types,
                    enum_decls, variants, fn_ret_map, nt, tn, term);
                let cl_g: string = cg_fresh(tc, "%t");
                si(body, str_concat(cl_g, str_concat(
                    " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                    str_concat(cl_ap, ", i32 0, i32 1"))));
                let cl_v: string = cg_fresh(tc, "%t");
                si(body, str_concat(cl_v, str_concat(" = load i64, ptr ", cl_g)));
                return cl_v;
            }
            // push(arr, val)
            if str_eq(cfn, "push") {
                let cp_ap: string = cg_expr(idx_lists[e.n2], exprs, idx_lists,
                    body, globals, tc, lc, sc, scopes, vptrs, vtys, vtids,
                    arr_map, arr_etypes, struct_decls, fields, types,
                    enum_decls, variants, fn_ret_map, nt, tn, term);
                let cp_ae: Expr = exprs[idx_lists[e.n2]];
                let mut cp_ety: string = "i64";
                if cp_ae.tag == 5 {
                    if map_has(arr_map, cp_ae.s1) {
                        cp_ety = arr_etypes[map_get(arr_map, cp_ae.s1)];
                    }
                }
                let cp_esz: int = cg_sizeof(cp_ety, struct_decls, fields, types, tn, nt);
                let cp_dg: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_dg, str_concat(
                    " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                    str_concat(cp_ap, ", i32 0, i32 0"))));
                let cp_dp: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_dp, str_concat(" = load ptr, ptr ", cp_dg)));
                let cp_lg: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_lg, str_concat(
                    " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                    str_concat(cp_ap, ", i32 0, i32 1"))));
                let cp_lv: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_lv, str_concat(" = load i64, ptr ", cp_lg)));
                let cp_cg: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_cg, str_concat(
                    " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                    str_concat(cp_ap, ", i32 0, i32 2"))));
                let cp_cv: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_cv, str_concat(" = load i64, ptr ", cp_cg)));
                // Check grow: len == cap
                let cp_ng: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_ng, str_concat(" = icmp eq i64 ",
                    str_concat(cp_lv, str_concat(", ", cp_cv)))));
                let cp_gl: string = cg_fresh(lc, "push.grow");
                let cp_sl: string = cg_fresh(lc, "push.store");
                si(body, str_concat("br i1 ", str_concat(cp_ng,
                    str_concat(", label %", str_concat(cp_gl,
                    str_concat(", label %", cp_sl))))));
                // Grow block
                sa(body, str_concat(cp_gl, ":"));
                let cp_dbl: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_dbl, str_concat(" = shl i64 ", str_concat(cp_cv, ", 1"))));
                let cp_iz: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_iz, str_concat(" = icmp eq i64 ", str_concat(cp_cv, ", 0"))));
                let cp_nc: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_nc, str_concat(" = select i1 ",
                    str_concat(cp_iz, str_concat(", i64 4, i64 ", cp_dbl)))));
                let cp_nb: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_nb, str_concat(" = mul i64 ",
                    str_concat(cp_nc, str_concat(", ", int_to_str(cp_esz))))));
                let cp_nd: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_nd, str_concat(" = call ptr @realloc(ptr ",
                    str_concat(cp_dp, str_concat(", i64 ", str_concat(cp_nb, ")"))))));
                si(body, str_concat("store ptr ", str_concat(cp_nd, str_concat(", ptr ", cp_dg))));
                si(body, str_concat("store i64 ", str_concat(cp_nc, str_concat(", ptr ", cp_cg))));
                si(body, str_concat("br label %", cp_sl));
                // Store block
                sa(body, str_concat(cp_sl, ":"));
                let cp_cd: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_cd, str_concat(" = load ptr, ptr ", cp_dg)));
                let cp_eg: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_eg, str_concat(" = getelementptr ",
                    str_concat(cp_ety, str_concat(", ptr ",
                    str_concat(cp_cd, str_concat(", i64 ", cp_lv)))))));
                if cg_is_agg(cp_ety) {
                    let cp_ve: Expr = exprs[idx_lists[e.n2 + 1]];
                    let mut cp_src: string = "";
                    if cp_ve.tag == 5 {
                        cp_src = cg_var_ptr(scopes, vptrs, cp_ve.s1);
                    } else {
                        let cp_vr: string = cg_expr(idx_lists[e.n2 + 1], exprs, idx_lists,
                            body, globals, tc, lc, sc, scopes, vptrs, vtys, vtids,
                            arr_map, arr_etypes, struct_decls, fields, types,
                            enum_decls, variants, fn_ret_map, nt, tn, term);
                        let mut cp_is_alloca: bool = false;
                        if cp_ve.tag == 12 { cp_is_alloca = true; }
                        if cp_ve.tag == 8 {
                            let cp_ce: Expr = exprs[cp_ve.n1];
                            if cp_ce.tag == 5 {
                                if str_len(cg_find_enum(cp_ce.s1, enum_decls, variants)) > 0 {
                                    cp_is_alloca = true;
                                }
                            }
                        }
                        if cp_is_alloca {
                            cp_src = cp_vr;
                        } else {
                            let cp_tmp: string = cg_fresh(tc, "%t");
                            si(body, str_concat(cp_tmp, str_concat(" = alloca ", cp_ety)));
                            si(body, str_concat("store ", str_concat(cp_ety,
                                str_concat(" ", str_concat(cp_vr, str_concat(", ptr ", cp_tmp))))));
                            cp_src = cp_tmp;
                        }
                    }
                    si(body, str_concat("call ptr @memcpy(ptr ",
                        str_concat(cp_eg, str_concat(", ptr ",
                        str_concat(cp_src, str_concat(", i64 ", str_concat(int_to_str(cp_esz), ")")))))));
                } else {
                    let cp_ev: string = cg_expr(idx_lists[e.n2 + 1], exprs, idx_lists,
                        body, globals, tc, lc, sc, scopes, vptrs, vtys, vtids,
                        arr_map, arr_etypes, struct_decls, fields, types,
                        enum_decls, variants, fn_ret_map, nt, tn, term);
                    si(body, str_concat("store ", str_concat(cp_ety,
                        str_concat(" ", str_concat(cp_ev, str_concat(", ptr ", cp_eg))))));
                }
                let cp_nl: string = cg_fresh(tc, "%t");
                si(body, str_concat(cp_nl, str_concat(" = add i64 ", str_concat(cp_lv, ", 1"))));
                si(body, str_concat("store i64 ", str_concat(cp_nl, str_concat(", ptr ", cp_lg))));
                return "void";
            }
            // pop(arr)
            if str_eq(cfn, "pop") {
                let pp_ap: string = cg_expr(idx_lists[e.n2], exprs, idx_lists,
                    body, globals, tc, lc, sc, scopes, vptrs, vtys, vtids,
                    arr_map, arr_etypes, struct_decls, fields, types,
                    enum_decls, variants, fn_ret_map, nt, tn, term);
                let pp_ae: Expr = exprs[idx_lists[e.n2]];
                let mut pp_ety: string = "i64";
                if pp_ae.tag == 5 {
                    if map_has(arr_map, pp_ae.s1) {
                        pp_ety = arr_etypes[map_get(arr_map, pp_ae.s1)];
                    }
                }
                let pp_lg: string = cg_fresh(tc, "%t");
                si(body, str_concat(pp_lg, str_concat(
                    " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                    str_concat(pp_ap, ", i32 0, i32 1"))));
                let pp_lv: string = cg_fresh(tc, "%t");
                si(body, str_concat(pp_lv, str_concat(" = load i64, ptr ", pp_lg)));
                let pp_ie: string = cg_fresh(tc, "%t");
                si(body, str_concat(pp_ie, str_concat(" = icmp eq i64 ", str_concat(pp_lv, ", 0"))));
                let pp_fl: string = cg_fresh(lc, "pop.fail");
                let pp_ol: string = cg_fresh(lc, "pop.ok");
                si(body, str_concat("br i1 ", str_concat(pp_ie,
                    str_concat(", label %", str_concat(pp_fl,
                    str_concat(", label %", pp_ol))))));
                sa(body, str_concat(pp_fl, ":"));
                si(body, "call i32 (ptr, ...) @printf(ptr @.fmt.pop_empty)");
                si(body, "call void @abort()");
                si(body, "unreachable");
                sa(body, str_concat(pp_ol, ":"));
                let pp_nl: string = cg_fresh(tc, "%t");
                si(body, str_concat(pp_nl, str_concat(" = sub i64 ", str_concat(pp_lv, ", 1"))));
                si(body, str_concat("store i64 ", str_concat(pp_nl, str_concat(", ptr ", pp_lg))));
                let pp_dg: string = cg_fresh(tc, "%t");
                si(body, str_concat(pp_dg, str_concat(
                    " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                    str_concat(pp_ap, ", i32 0, i32 0"))));
                let pp_dp: string = cg_fresh(tc, "%t");
                si(body, str_concat(pp_dp, str_concat(" = load ptr, ptr ", pp_dg)));
                let pp_eg: string = cg_fresh(tc, "%t");
                si(body, str_concat(pp_eg, str_concat(" = getelementptr ",
                    str_concat(pp_ety, str_concat(", ptr ",
                    str_concat(pp_dp, str_concat(", i64 ", pp_nl)))))));
                if cg_is_agg(pp_ety) {
                    let pp_ta: string = cg_fresh(tc, "%t");
                    si(body, str_concat(pp_ta, str_concat(" = alloca ", pp_ety)));
                    si(body, str_concat("call ptr @memcpy(ptr ",
                        str_concat(pp_ta, str_concat(", ptr ",
                        str_concat(pp_eg, str_concat(", i64 ", str_concat(int_to_str(cg_sizeof(pp_ety, struct_decls, fields, types, tn, nt)), ")")))))));
                    return pp_ta;
                }
                let pp_pv: string = cg_fresh(tc, "%t");
                si(body, str_concat(pp_pv, str_concat(" = load ",
                    str_concat(pp_ety, str_concat(", ptr ", pp_eg)))));
                return pp_pv;
            }
            // exit(code)
            if str_eq(cfn, "exit") {
                let ex_code: string = cg_expr(idx_lists[e.n2], exprs, idx_lists,
                    body, globals, tc, lc, sc, scopes, vptrs, vtys, vtids,
                    arr_map, arr_etypes, struct_decls, fields, types,
                    enum_decls, variants, fn_ret_map, nt, tn, term);
                let ex_c32: string = cg_fresh(tc, "%t");
                si(body, str_concat(ex_c32, str_concat(" = trunc i64 ", str_concat(ex_code, " to i32"))));
                si(body, str_concat("call void @exit(i32 ", str_concat(ex_c32, ")")));
                si(body, "unreachable");
                let mut ex_tm: [int] = term;
                ex_tm[0] = 1;
                return "void";
            }
            // args()
            if str_eq(cfn, "args") {
                let ar_32: string = cg_fresh(tc, "%t");
                si(body, str_concat(ar_32, " = load i32, ptr @__yorum_argc"));
                let ar_ac: string = cg_fresh(tc, "%t");
                si(body, str_concat(ar_ac, str_concat(" = zext i32 ", str_concat(ar_32, " to i64"))));
                let ar_av: string = cg_fresh(tc, "%t");
                si(body, str_concat(ar_av, " = load ptr, ptr @__yorum_argv"));
                let ar_by: string = cg_fresh(tc, "%t");
                si(body, str_concat(ar_by, str_concat(" = mul i64 ", str_concat(ar_ac, ", 8"))));
                let ar_dt: string = cg_fresh(tc, "%t");
                si(body, str_concat(ar_dt, str_concat(" = call ptr @malloc(i64 ", str_concat(ar_by, ")"))));
                si(body, str_concat("call ptr @memcpy(ptr ", str_concat(ar_dt,
                    str_concat(", ptr ", str_concat(ar_av, str_concat(", i64 ", str_concat(ar_by, ")")))))));
                let ar_fat: string = cg_fresh(tc, "%t");
                si(body, str_concat(ar_fat, " = alloca {{ ptr, i64, i64 }}"));
                let ar_g1: string = cg_fresh(tc, "%t");
                si(body, str_concat(ar_g1, str_concat(
                    " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                    str_concat(ar_fat, ", i32 0, i32 0"))));
                si(body, str_concat("store ptr ", str_concat(ar_dt, str_concat(", ptr ", ar_g1))));
                let ar_g2: string = cg_fresh(tc, "%t");
                si(body, str_concat(ar_g2, str_concat(
                    " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                    str_concat(ar_fat, ", i32 0, i32 1"))));
                si(body, str_concat("store i64 ", str_concat(ar_ac, str_concat(", ptr ", ar_g2))));
                let ar_g3: string = cg_fresh(tc, "%t");
                si(body, str_concat(ar_g3, str_concat(
                    " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                    str_concat(ar_fat, ", i32 0, i32 2"))));
                si(body, str_concat("store i64 ", str_concat(ar_ac, str_concat(", ptr ", ar_g3))));
                return ar_fat;
            }
            // Enum variant constructor
            let ev_en: string = cg_find_enum(cfn, enum_decls, variants);
            if str_len(ev_en) > 0 {
                let ev_tag: int = cg_variant_tag(cfn, enum_decls, variants);
                let ev_ep: string = cg_fresh(tc, "%t");
                si(body, str_concat(ev_ep, str_concat(" = alloca %", ev_en)));
                let ev_tg: string = cg_fresh(tc, "%t");
                si(body, str_concat(ev_tg, str_concat(" = getelementptr %",
                    str_concat(ev_en, str_concat(", ptr ",
                    str_concat(ev_ep, ", i32 0, i32 0"))))));
                si(body, str_concat("store i32 ", str_concat(int_to_str(ev_tag),
                    str_concat(", ptr ", ev_tg))));
                if e.n3 > 0 {
                    let ev_pg: string = cg_fresh(tc, "%t");
                    si(body, str_concat(ev_pg, str_concat(" = getelementptr %",
                        str_concat(ev_en, str_concat(", ptr ",
                        str_concat(ev_ep, ", i32 0, i32 1"))))));
                    let mut ev_bo: int = 0;
                    let mut ev_ai: int = 0;
                    while ev_ai < e.n3 {
                        let ev_av: string = cg_expr(idx_lists[e.n2 + ev_ai], exprs, idx_lists,
                            body, globals, tc, lc, sc, scopes, vptrs, vtys, vtids,
                            arr_map, arr_etypes, struct_decls, fields, types,
                            enum_decls, variants, fn_ret_map, nt, tn, term);
                        let ev_at: string = cg_expr_ty(idx_lists[e.n2 + ev_ai], exprs, idx_lists,
                            scopes, vtys, vtids, arr_map, arr_etypes, fn_ret_map, nt, tn,
                            struct_decls, fields, types, enum_decls, variants);
                        let ev_fp: string = cg_fresh(tc, "%t");
                        si(body, str_concat(ev_fp, str_concat(
                            " = getelementptr [0 x i8], ptr ",
                            str_concat(ev_pg, str_concat(", i64 0, i64 ", int_to_str(ev_bo))))));
                        si(body, str_concat("store ", str_concat(ev_at,
                            str_concat(" ", str_concat(ev_av, str_concat(", ptr ", ev_fp))))));
                        ev_bo = ev_bo + cg_sizeof(ev_at, struct_decls, fields, types, tn, nt);
                        ev_ai = ev_ai + 1;
                    }
                }
                return ev_ep;
            }
            // Normal function call
            if map_has(fn_ret_map, cfn) {
                let nc_ret: int = map_get(fn_ret_map, cfn);
                let nc_rty: string = cg_type(nc_ret, nt);
                let mut nc_args: string = "";
                let mut nc_ai: int = 0;
                while nc_ai < e.n3 {
                    let nc_aex: int = idx_lists[e.n2 + nc_ai];
                    let nc_av: string = cg_expr(nc_aex, exprs, idx_lists,
                        body, globals, tc, lc, sc, scopes, vptrs, vtys, vtids,
                        arr_map, arr_etypes, struct_decls, fields, types,
                        enum_decls, variants, fn_ret_map, nt, tn, term);
                    let mut nc_at: string = cg_expr_ty(nc_aex, exprs, idx_lists,
                        scopes, vtys, vtids, arr_map, arr_etypes, fn_ret_map, nt, tn,
                        struct_decls, fields, types, enum_decls, variants);
                    if str_eq(nc_at, "{{ ptr, i64, i64 }}") { nc_at = "ptr"; }
                    let mut nc_fv: string = nc_av;
                    let nc_ae: Expr = exprs[nc_aex];
                    if str_charAt(nc_at, 0) == '%' {
                        let mut nc_needs_load: bool = false;
                        if nc_ae.tag == 12 { nc_needs_load = true; }
                        if nc_ae.tag == 8 {
                            let nc_ce: Expr = exprs[nc_ae.n1];
                            if nc_ce.tag == 5 {
                                if str_len(cg_find_enum(nc_ce.s1, enum_decls, variants)) > 0 {
                                    nc_needs_load = true;
                                }
                            }
                        }
                        if nc_needs_load {
                            let nc_ld: string = cg_fresh(tc, "%t");
                            si(body, str_concat(nc_ld, str_concat(" = load ",
                                str_concat(nc_at, str_concat(", ptr ", nc_av)))));
                            nc_fv = nc_ld;
                        }
                    }
                    if nc_ai > 0 { nc_args = str_concat(nc_args, ", "); }
                    nc_args = str_concat(nc_args, str_concat(nc_at, str_concat(" ", nc_fv)));
                    nc_ai = nc_ai + 1;
                }
                if str_eq(nc_rty, "void") {
                    si(body, str_concat("call void @", str_concat(cfn,
                        str_concat("(", str_concat(nc_args, ")")))));
                    return "void";
                }
                let nc_t: string = cg_fresh(tc, "%t");
                si(body, str_concat(nc_t, str_concat(" = call ", str_concat(nc_rty,
                    str_concat(" @", str_concat(cfn,
                    str_concat("(", str_concat(nc_args, ")"))))))));
                return nc_t;
            }
        }
        return "0";
    }
    // FieldAccess
    if e.tag == 9 {
        let fa_op: string = cg_expr_ptr(e.n1, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        let fa_sn: string = cg_sname(e.n1, exprs, idx_lists, scopes, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types);
        let fa_fi: int = cg_field_idx(fa_sn, e.s1, struct_decls, fields);
        let fa_ft: string = cg_field_ty(fa_sn, e.s1, struct_decls, fields, types, tn, nt);
        let fa_gp: string = cg_fresh(tc, "%t");
        si(body, str_concat(fa_gp, str_concat(" = getelementptr %",
            str_concat(fa_sn, str_concat(", ptr ",
            str_concat(fa_op, str_concat(", i32 0, i32 ", int_to_str(fa_fi))))))));
        let fa_fv: string = cg_fresh(tc, "%t");
        si(body, str_concat(fa_fv, str_concat(" = load ",
            str_concat(fa_ft, str_concat(", ptr ", fa_gp)))));
        return fa_fv;
    }
    // Index
    if e.tag == 11 {
        let ix_ae: Expr = exprs[e.n1];
        let mut ix_ety: string = "i64";
        if ix_ae.tag == 5 {
            if map_has(arr_map, ix_ae.s1) {
                ix_ety = arr_etypes[map_get(arr_map, ix_ae.s1)];
            }
        }
        let ix_ap: string = cg_expr_ptr(e.n1, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        let ix_dg: string = cg_fresh(tc, "%t");
        si(body, str_concat(ix_dg, str_concat(
            " = getelementptr {{ ptr, i64, i64 }}, ptr ",
            str_concat(ix_ap, ", i32 0, i32 0"))));
        let ix_dp: string = cg_fresh(tc, "%t");
        si(body, str_concat(ix_dp, str_concat(" = load ptr, ptr ", ix_dg)));
        let ix_lg: string = cg_fresh(tc, "%t");
        si(body, str_concat(ix_lg, str_concat(
            " = getelementptr {{ ptr, i64, i64 }}, ptr ",
            str_concat(ix_ap, ", i32 0, i32 1"))));
        let ix_lv: string = cg_fresh(tc, "%t");
        si(body, str_concat(ix_lv, str_concat(" = load i64, ptr ", ix_lg)));
        let ix_iv: string = cg_expr(e.n2, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        si(body, str_concat("call void @__yorum_bounds_check(i64 ",
            str_concat(ix_iv, str_concat(", i64 ", str_concat(ix_lv, ")")))));
        let ix_eg: string = cg_fresh(tc, "%t");
        si(body, str_concat(ix_eg, str_concat(" = getelementptr ",
            str_concat(ix_ety, str_concat(", ptr ",
            str_concat(ix_dp, str_concat(", i64 ", ix_iv)))))));
        if cg_is_agg(ix_ety) {
            let ix_ta: string = cg_fresh(tc, "%t");
            si(body, str_concat(ix_ta, str_concat(" = alloca ", ix_ety)));
            si(body, str_concat("call ptr @memcpy(ptr ",
                str_concat(ix_ta, str_concat(", ptr ",
                str_concat(ix_eg, str_concat(", i64 ", str_concat(int_to_str(cg_sizeof(ix_ety, struct_decls, fields, types, tn, nt)), ")")))))));
            return ix_ta;
        }
        let ix_rv: string = cg_fresh(tc, "%t");
        si(body, str_concat(ix_rv, str_concat(" = load ",
            str_concat(ix_ety, str_concat(", ptr ", ix_eg)))));
        return ix_rv;
    }
    // StructInit
    if e.tag == 12 {
        let si_sp: string = cg_fresh(tc, "%t");
        si(body, str_concat(si_sp, str_concat(" = alloca %", e.s1)));
        let mut si_fi: int = 0;
        while si_fi < e.n2 {
            let si_nidx: int = idx_lists[e.n1 + si_fi * 2];
            let si_vidx: int = idx_lists[e.n1 + si_fi * 2 + 1];
            let si_fn: string = exprs[si_nidx].s1;
            let si_fidx: int = cg_field_idx(e.s1, si_fn, struct_decls, fields);
            let si_fty: string = cg_field_ty(e.s1, si_fn, struct_decls, fields, types, tn, nt);
            let si_fv: string = cg_expr(si_vidx, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
            let si_gp: string = cg_fresh(tc, "%t");
            si(body, str_concat(si_gp, str_concat(" = getelementptr %",
                str_concat(e.s1, str_concat(", ptr ",
                str_concat(si_sp, str_concat(", i32 0, i32 ", int_to_str(si_fidx))))))));
            si(body, str_concat("store ", str_concat(si_fty,
                str_concat(" ", str_concat(si_fv, str_concat(", ptr ", si_gp))))));
            si_fi = si_fi + 1;
        }
        return si_sp;
    }
    // ArrayLit
    if e.tag == 13 {
        let al_cnt: int = e.n2;
        let al_fat: string = cg_fresh(tc, "%t");
        si(body, str_concat(al_fat, " = alloca {{ ptr, i64, i64 }}"));
        if al_cnt == 0 {
            let al_dg0: string = cg_fresh(tc, "%t");
            si(body, str_concat(al_dg0, str_concat(
                " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                str_concat(al_fat, ", i32 0, i32 0"))));
            si(body, str_concat("store ptr null, ptr ", al_dg0));
            let al_lg0: string = cg_fresh(tc, "%t");
            si(body, str_concat(al_lg0, str_concat(
                " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                str_concat(al_fat, ", i32 0, i32 1"))));
            si(body, str_concat("store i64 0, ptr ", al_lg0));
            let al_cg0: string = cg_fresh(tc, "%t");
            si(body, str_concat(al_cg0, str_concat(
                " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                str_concat(al_fat, ", i32 0, i32 2"))));
            si(body, str_concat("store i64 0, ptr ", al_cg0));
            return al_fat;
        }
        let al_ety: string = cg_expr_ty(idx_lists[e.n1], exprs, idx_lists,
            scopes, vtys, vtids, arr_map, arr_etypes, fn_ret_map, nt, tn,
            struct_decls, fields, types, enum_decls, variants);
        let al_esz: int = cg_sizeof(al_ety, struct_decls, fields, types, tn, nt);
        let al_total: int = al_esz * al_cnt;
        let al_dt: string = cg_fresh(tc, "%t");
        si(body, str_concat(al_dt, str_concat(" = call ptr @malloc(i64 ",
            str_concat(int_to_str(al_total), ")"))));
        let mut al_ei: int = 0;
        while al_ei < al_cnt {
            let al_eg: string = cg_fresh(tc, "%t");
            si(body, str_concat(al_eg, str_concat(" = getelementptr ",
                str_concat(al_ety, str_concat(", ptr ",
                str_concat(al_dt, str_concat(", i64 ", int_to_str(al_ei))))))));
            if cg_is_agg(al_ety) {
                let al_ve: Expr = exprs[idx_lists[e.n1 + al_ei]];
                let mut al_src: string = "";
                if al_ve.tag == 5 {
                    al_src = cg_var_ptr(scopes, vptrs, al_ve.s1);
                } else {
                    let al_vr: string = cg_expr(idx_lists[e.n1 + al_ei], exprs, idx_lists,
                        body, globals, tc, lc, sc, scopes, vptrs, vtys, vtids,
                        arr_map, arr_etypes, struct_decls, fields, types,
                        enum_decls, variants, fn_ret_map, nt, tn, term);
                    let mut al_is_alloca: bool = false;
                    if al_ve.tag == 12 { al_is_alloca = true; }
                    if al_ve.tag == 8 {
                        let al_ce: Expr = exprs[al_ve.n1];
                        if al_ce.tag == 5 {
                            if str_len(cg_find_enum(al_ce.s1, enum_decls, variants)) > 0 {
                                al_is_alloca = true;
                            }
                        }
                    }
                    if al_is_alloca {
                        al_src = al_vr;
                    } else {
                        let al_tmp: string = cg_fresh(tc, "%t");
                        si(body, str_concat(al_tmp, str_concat(" = alloca ", al_ety)));
                        si(body, str_concat("store ", str_concat(al_ety,
                            str_concat(" ", str_concat(al_vr, str_concat(", ptr ", al_tmp))))));
                        al_src = al_tmp;
                    }
                }
                si(body, str_concat("call ptr @memcpy(ptr ",
                    str_concat(al_eg, str_concat(", ptr ",
                    str_concat(al_src, str_concat(", i64 ", str_concat(int_to_str(al_esz), ")")))))));
            } else {
                let al_ev: string = cg_expr(idx_lists[e.n1 + al_ei], exprs, idx_lists,
                    body, globals, tc, lc, sc, scopes, vptrs, vtys, vtids,
                    arr_map, arr_etypes, struct_decls, fields, types,
                    enum_decls, variants, fn_ret_map, nt, tn, term);
                si(body, str_concat("store ", str_concat(al_ety,
                    str_concat(" ", str_concat(al_ev, str_concat(", ptr ", al_eg))))));
            }
            al_ei = al_ei + 1;
        }
        let al_fg1: string = cg_fresh(tc, "%t");
        si(body, str_concat(al_fg1, str_concat(
            " = getelementptr {{ ptr, i64, i64 }}, ptr ",
            str_concat(al_fat, ", i32 0, i32 0"))));
        si(body, str_concat("store ptr ", str_concat(al_dt, str_concat(", ptr ", al_fg1))));
        let al_fg2: string = cg_fresh(tc, "%t");
        si(body, str_concat(al_fg2, str_concat(
            " = getelementptr {{ ptr, i64, i64 }}, ptr ",
            str_concat(al_fat, ", i32 0, i32 1"))));
        si(body, str_concat("store i64 ", str_concat(int_to_str(al_cnt),
            str_concat(", ptr ", al_fg2))));
        let al_fg3: string = cg_fresh(tc, "%t");
        si(body, str_concat(al_fg3, str_concat(
            " = getelementptr {{ ptr, i64, i64 }}, ptr ",
            str_concat(al_fat, ", i32 0, i32 2"))));
        si(body, str_concat("store i64 ", str_concat(int_to_str(al_cnt),
            str_concat(", ptr ", al_fg3))));
        return al_fat;
    }
    return "0";
}

// ── Statement emission ──

fn cg_block(bi: int, blocks: [Block], stmts: [Stmt], exprs: [Expr], idx_lists: [int],
    pats: [Pattern], arms_pool: [MatchArm],
    body: [string], globals: [string],
    tc: [int], lc: [int], sc: [int],
    scopes: [Map], vptrs: [string], vtys: [string], vtids: [int],
    arr_map: Map, arr_etypes: [string],
    struct_decls: [StructDecl], fields: [Field], types: [TypeNode],
    enum_decls: [EnumDecl], variants: [Variant],
    fn_ret_map: Map, nt: [string], tn: Map,
    term: [int], ret_ty: string) -> int {
    let blk: Block = blocks[bi];
    let mut bi_i: int = 0;
    while bi_i < blk.count {
        if term[0] == 0 {
            cg_stmt(idx_lists[blk.first + bi_i], stmts, blocks, exprs, idx_lists,
                pats, arms_pool, body, globals, tc, lc, sc,
                scopes, vptrs, vtys, vtids, arr_map, arr_etypes,
                struct_decls, fields, types, enum_decls, variants,
                fn_ret_map, nt, tn, term, ret_ty);
        }
        bi_i = bi_i + 1;
    }
    return 0;
}

fn cg_stmt(si_p: int, stmts: [Stmt], blocks: [Block], exprs: [Expr], idx_lists: [int],
    pats: [Pattern], arms_pool: [MatchArm],
    body: [string], globals: [string],
    tc: [int], lc: [int], sc: [int],
    scopes: [Map], vptrs: [string], vtys: [string], vtids: [int],
    arr_map: Map, arr_etypes: [string],
    struct_decls: [StructDecl], fields: [Field], types: [TypeNode],
    enum_decls: [EnumDecl], variants: [Variant],
    fn_ret_map: Map, nt: [string], tn: Map,
    term: [int], ret_ty: string) -> int {
    let s: Stmt = stmts[si_p];
    // Let
    if s.tag == 1 {
        let lt_tid: int = resolve_type(s.n1, types, tn);
        let lt_ty: string = cg_type(lt_tid, nt);
        // Struct or enum: reuse alloca from constructor
        if lt_tid >= 100 {
            if lt_tid < 1000 {
                let lt_val: string = cg_expr(s.n2, exprs, idx_lists, body, globals,
                    tc, lc, sc, scopes, vptrs, vtys, vtids,
                    arr_map, arr_etypes, struct_decls, fields, types,
                    enum_decls, variants, fn_ret_map, nt, tn, term);
                cg_def_var(scopes, vptrs, vtys, vtids, s.s1, lt_val, lt_ty, lt_tid);
                return 0;
            }
        }
        // Array: reuse fat ptr alloca
        if lt_tid >= 1000 {
            let lt_elem_tid: int = lt_tid - 1000;
            let lt_elem_ty: string = cg_type(lt_elem_tid, nt);
            let lt_aval: string = cg_expr(s.n2, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
            cg_def_var(scopes, vptrs, vtys, vtids, s.s1, lt_aval, "{{ ptr, i64, i64 }}", lt_tid);
            map_set(arr_map, s.s1, len(arr_etypes));
            let mut lt_aet: [string] = arr_etypes;
            push(lt_aet, lt_elem_ty);
            return 0;
        }
        // Map: reuse ptr directly
        if lt_tid == 7 {
            let lt_mval: string = cg_expr(s.n2, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
            let lt_mptr: string = str_concat("%", str_concat(s.s1, ".addr"));
            si(body, str_concat(lt_mptr, str_concat(" = alloca ", lt_ty)));
            si(body, str_concat("store ", str_concat(lt_ty, str_concat(" ",
                str_concat(lt_mval, str_concat(", ptr ", lt_mptr))))));
            cg_def_var(scopes, vptrs, vtys, vtids, s.s1, lt_mptr, lt_ty, lt_tid);
            return 0;
        }
        // Normal: alloca + store
        let lt_ptr: string = str_concat("%", str_concat(s.s1, ".addr"));
        si(body, str_concat(lt_ptr, str_concat(" = alloca ", lt_ty)));
        let lt_v: string = cg_expr(s.n2, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        si(body, str_concat("store ", str_concat(lt_ty, str_concat(" ",
            str_concat(lt_v, str_concat(", ptr ", lt_ptr))))));
        cg_def_var(scopes, vptrs, vtys, vtids, s.s1, lt_ptr, lt_ty, lt_tid);
        return 0;
    }
    // Assign
    if s.tag == 2 {
        let as_tgt: Expr = exprs[s.n1];
        // Assign to ident
        if as_tgt.tag == 5 {
            let as_ty: string = cg_var_ty(scopes, vtys, as_tgt.s1);
            let as_val: string = cg_expr(s.n2, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
            si(body, str_concat("store ", str_concat(as_ty, str_concat(" ",
                str_concat(as_val, str_concat(", ptr ",
                cg_var_ptr(scopes, vptrs, as_tgt.s1)))))));
            return 0;
        }
        // Assign to field
        if as_tgt.tag == 9 {
            let as_op: string = cg_expr_ptr(as_tgt.n1, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
            let as_sn: string = cg_sname(as_tgt.n1, exprs, idx_lists, scopes, vtids,
                arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types);
            let as_fi: int = cg_field_idx(as_sn, as_tgt.s1, struct_decls, fields);
            let as_ft: string = cg_field_ty(as_sn, as_tgt.s1, struct_decls, fields, types, tn, nt);
            let as_gp: string = cg_fresh(tc, "%t");
            si(body, str_concat(as_gp, str_concat(" = getelementptr %",
                str_concat(as_sn, str_concat(", ptr ",
                str_concat(as_op, str_concat(", i32 0, i32 ", int_to_str(as_fi))))))));
            let as_fval: string = cg_expr(s.n2, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
            si(body, str_concat("store ", str_concat(as_ft, str_concat(" ",
                str_concat(as_fval, str_concat(", ptr ", as_gp))))));
            return 0;
        }
        // Assign to index: arr[idx] = val
        if as_tgt.tag == 11 {
            let as_ae: Expr = exprs[as_tgt.n1];
            let mut as_ety: string = "i64";
            if as_ae.tag == 5 {
                if map_has(arr_map, as_ae.s1) {
                    as_ety = arr_etypes[map_get(arr_map, as_ae.s1)];
                }
            }
            let as_ap: string = cg_expr_ptr(as_tgt.n1, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
            let as_dg: string = cg_fresh(tc, "%t");
            si(body, str_concat(as_dg, str_concat(
                " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                str_concat(as_ap, ", i32 0, i32 0"))));
            let as_dp: string = cg_fresh(tc, "%t");
            si(body, str_concat(as_dp, str_concat(" = load ptr, ptr ", as_dg)));
            let as_lg: string = cg_fresh(tc, "%t");
            si(body, str_concat(as_lg, str_concat(
                " = getelementptr {{ ptr, i64, i64 }}, ptr ",
                str_concat(as_ap, ", i32 0, i32 1"))));
            let as_lv: string = cg_fresh(tc, "%t");
            si(body, str_concat(as_lv, str_concat(" = load i64, ptr ", as_lg)));
            let as_iv: string = cg_expr(as_tgt.n2, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
            si(body, str_concat("call void @__yorum_bounds_check(i64 ",
                str_concat(as_iv, str_concat(", i64 ", str_concat(as_lv, ")")))));
            let as_eg: string = cg_fresh(tc, "%t");
            si(body, str_concat(as_eg, str_concat(" = getelementptr ",
                str_concat(as_ety, str_concat(", ptr ",
                str_concat(as_dp, str_concat(", i64 ", as_iv)))))));
            let as_sv: string = cg_expr(s.n2, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
            si(body, str_concat("store ", str_concat(as_ety, str_concat(" ",
                str_concat(as_sv, str_concat(", ptr ", as_eg))))));
            return 0;
        }
        return 0;
    }
    // Return
    if s.tag == 3 {
        if str_eq(ret_ty, "void") {
            si(body, "ret void");
        } else {
            let rt_v: string = cg_expr(s.n1, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
            si(body, str_concat("ret ", str_concat(ret_ty, str_concat(" ", rt_v))));
        }
        let mut rt_tm: [int] = term;
        rt_tm[0] = 1;
        return 0;
    }
    // If
    if s.tag == 4 {
        let if_cv: string = cg_expr(s.n1, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        let if_then: string = cg_fresh(lc, "then");
        let if_else: string = cg_fresh(lc, "else");
        let if_merge: string = cg_fresh(lc, "ifcont");
        let if_has_else: bool = s.n3 >= 0;
        let if_has_elif: bool = s.n4 >= 0;
        let mut if_target: string = if_merge;
        if if_has_else { if_target = if_else; }
        if if_has_elif { if_target = if_else; }
        si(body, str_concat("br i1 ", str_concat(if_cv,
            str_concat(", label %", str_concat(if_then,
            str_concat(", label %", if_target))))));
        // Then block
        sa(body, str_concat(if_then, ":"));
        let mut if_ttm: [int] = term;
        if_ttm[0] = 0;
        cg_push_scope(scopes);
        cg_block(s.n2, blocks, stmts, exprs, idx_lists,
            pats, arms_pool, body, globals, tc, lc, sc,
            scopes, vptrs, vtys, vtids, arr_map, arr_etypes,
            struct_decls, fields, types, enum_decls, variants,
            fn_ret_map, nt, tn, term, ret_ty);
        cg_pop_scope(scopes);
        let if_then_term: int = term[0];
        if term[0] == 0 {
            si(body, str_concat("br label %", if_merge));
        }
        // Else/else-if block
        if if_has_else {
            sa(body, str_concat(if_else, ":"));
            let mut if_etm: [int] = term;
            if_etm[0] = 0;
            cg_push_scope(scopes);
            cg_block(s.n3, blocks, stmts, exprs, idx_lists,
                pats, arms_pool, body, globals, tc, lc, sc,
                scopes, vptrs, vtys, vtids, arr_map, arr_etypes,
                struct_decls, fields, types, enum_decls, variants,
                fn_ret_map, nt, tn, term, ret_ty);
            cg_pop_scope(scopes);
            if term[0] == 0 {
                si(body, str_concat("br label %", if_merge));
            }
        }
        if if_has_elif {
            sa(body, str_concat(if_else, ":"));
            let mut if_eitm: [int] = term;
            if_eitm[0] = 0;
            cg_stmt(s.n4, stmts, blocks, exprs, idx_lists,
                pats, arms_pool, body, globals, tc, lc, sc,
                scopes, vptrs, vtys, vtids, arr_map, arr_etypes,
                struct_decls, fields, types, enum_decls, variants,
                fn_ret_map, nt, tn, term, ret_ty);
            if term[0] == 0 {
                si(body, str_concat("br label %", if_merge));
            }
        }
        // Merge
        sa(body, str_concat(if_merge, ":"));
        let mut if_mtm: [int] = term;
        if_mtm[0] = 0;
        return 0;
    }
    // While
    if s.tag == 5 {
        let wh_cond: string = cg_fresh(lc, "while.cond");
        let wh_body: string = cg_fresh(lc, "while.body");
        let wh_end: string = cg_fresh(lc, "while.end");
        si(body, str_concat("br label %", wh_cond));
        sa(body, str_concat(wh_cond, ":"));
        let mut wh_tm: [int] = term;
        wh_tm[0] = 0;
        let wh_cv: string = cg_expr(s.n1, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        si(body, str_concat("br i1 ", str_concat(wh_cv,
            str_concat(", label %", str_concat(wh_body,
            str_concat(", label %", wh_end))))));
        sa(body, str_concat(wh_body, ":"));
        let mut wh_btm: [int] = term;
        wh_btm[0] = 0;
        cg_push_scope(scopes);
        cg_block(s.n2, blocks, stmts, exprs, idx_lists,
            pats, arms_pool, body, globals, tc, lc, sc,
            scopes, vptrs, vtys, vtids, arr_map, arr_etypes,
            struct_decls, fields, types, enum_decls, variants,
            fn_ret_map, nt, tn, term, ret_ty);
        cg_pop_scope(scopes);
        if term[0] == 0 {
            si(body, str_concat("br label %", wh_cond));
        }
        sa(body, str_concat(wh_end, ":"));
        let mut wh_etm: [int] = term;
        wh_etm[0] = 0;
        return 0;
    }
    // For
    if s.tag == 6 {
        let fo_arr: string = cg_expr(s.n1, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        let fo_ae: Expr = exprs[s.n1];
        let mut fo_ety: string = "i64";
        if fo_ae.tag == 5 {
            if map_has(arr_map, fo_ae.s1) {
                fo_ety = arr_etypes[map_get(arr_map, fo_ae.s1)];
            }
        }
        // Load data ptr and length
        let fo_dg: string = cg_fresh(tc, "%t");
        si(body, str_concat(fo_dg, str_concat(
            " = getelementptr {{ ptr, i64, i64 }}, ptr ",
            str_concat(fo_arr, ", i32 0, i32 0"))));
        let fo_dp: string = cg_fresh(tc, "%t");
        si(body, str_concat(fo_dp, str_concat(" = load ptr, ptr ", fo_dg)));
        let fo_lg: string = cg_fresh(tc, "%t");
        si(body, str_concat(fo_lg, str_concat(
            " = getelementptr {{ ptr, i64, i64 }}, ptr ",
            str_concat(fo_arr, ", i32 0, i32 1"))));
        let fo_lv: string = cg_fresh(tc, "%t");
        si(body, str_concat(fo_lv, str_concat(" = load i64, ptr ", fo_lg)));
        // Index counter
        let fo_ip: string = cg_fresh(tc, "%t");
        si(body, str_concat(fo_ip, " = alloca i64"));
        si(body, str_concat("store i64 0, ptr ", fo_ip));
        // Loop variable
        let fo_vp: string = str_concat("%", str_concat(s.s1, ".addr"));
        si(body, str_concat(fo_vp, str_concat(" = alloca ", fo_ety)));
        let fo_cond: string = cg_fresh(lc, "for.cond");
        let fo_body: string = cg_fresh(lc, "for.body");
        let fo_end: string = cg_fresh(lc, "for.end");
        si(body, str_concat("br label %", fo_cond));
        // Condition: idx < len
        sa(body, str_concat(fo_cond, ":"));
        let fo_ci: string = cg_fresh(tc, "%t");
        si(body, str_concat(fo_ci, str_concat(" = load i64, ptr ", fo_ip)));
        let fo_cmp: string = cg_fresh(tc, "%t");
        si(body, str_concat(fo_cmp, str_concat(" = icmp slt i64 ",
            str_concat(fo_ci, str_concat(", ", fo_lv)))));
        si(body, str_concat("br i1 ", str_concat(fo_cmp,
            str_concat(", label %", str_concat(fo_body,
            str_concat(", label %", fo_end))))));
        // Body
        sa(body, str_concat(fo_body, ":"));
        let mut fo_btm: [int] = term;
        fo_btm[0] = 0;
        cg_push_scope(scopes);
        // Load element at current index
        let fo_eg: string = cg_fresh(tc, "%t");
        si(body, str_concat(fo_eg, str_concat(" = getelementptr ",
            str_concat(fo_ety, str_concat(", ptr ",
            str_concat(fo_dp, str_concat(", i64 ", fo_ci)))))));
        let fo_ev: string = cg_fresh(tc, "%t");
        si(body, str_concat(fo_ev, str_concat(" = load ",
            str_concat(fo_ety, str_concat(", ptr ", fo_eg)))));
        si(body, str_concat("store ", str_concat(fo_ety,
            str_concat(" ", str_concat(fo_ev, str_concat(", ptr ", fo_vp))))));
        let fo_etid: int = cg_expr_tid(s.n1, exprs, idx_lists, scopes, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types);
        let mut fo_vtid: int = 1;
        if fo_etid >= 1000 { fo_vtid = fo_etid - 1000; }
        cg_def_var(scopes, vptrs, vtys, vtids, s.s1, fo_vp, fo_ety, fo_vtid);
        cg_block(s.n2, blocks, stmts, exprs, idx_lists,
            pats, arms_pool, body, globals, tc, lc, sc,
            scopes, vptrs, vtys, vtids, arr_map, arr_etypes,
            struct_decls, fields, types, enum_decls, variants,
            fn_ret_map, nt, tn, term, ret_ty);
        if term[0] == 0 {
            let fo_ci2: string = cg_fresh(tc, "%t");
            si(body, str_concat(fo_ci2, str_concat(" = load i64, ptr ", fo_ip)));
            let fo_ni: string = cg_fresh(tc, "%t");
            si(body, str_concat(fo_ni, str_concat(" = add i64 ", str_concat(fo_ci2, ", 1"))));
            si(body, str_concat("store i64 ", str_concat(fo_ni, str_concat(", ptr ", fo_ip))));
            si(body, str_concat("br label %", fo_cond));
        }
        cg_pop_scope(scopes);
        sa(body, str_concat(fo_end, ":"));
        let mut fo_etm: [int] = term;
        fo_etm[0] = 0;
        return 0;
    }
    // Match
    if s.tag == 7 {
        // Determine if subject is enum
        let mt_stid: int = cg_expr_tid(s.n1, exprs, idx_lists, scopes, vtids,
            arr_map, arr_etypes, fn_ret_map, nt, tn, struct_decls, fields, types);
        let mt_is_enum: bool = cg_is_enum(mt_stid, nt, enum_decls);
        let mt_subj: string = cg_expr(s.n1, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        // For enum: also get ptr for payload extraction
        let mut mt_subj_ptr: string = "";
        if mt_is_enum {
            mt_subj_ptr = cg_expr_ptr(s.n1, exprs, idx_lists, body, globals,
                tc, lc, sc, scopes, vptrs, vtys, vtids,
                arr_map, arr_etypes, struct_decls, fields, types,
                enum_decls, variants, fn_ret_map, nt, tn, term);
        }
        let mt_merge: string = cg_fresh(lc, "match.end");
        // Extract enum tag if needed
        let mut mt_cmp_val: string = mt_subj;
        if mt_is_enum {
            let mt_en: string = nt[mt_stid - 100];
            let mt_tg: string = cg_fresh(tc, "%t");
            si(body, str_concat(mt_tg, str_concat(" = getelementptr %",
                str_concat(mt_en, str_concat(", ptr ",
                str_concat(mt_subj_ptr, ", i32 0, i32 0"))))));
            let mt_tv: string = cg_fresh(tc, "%t");
            si(body, str_concat(mt_tv, str_concat(" = load i32, ptr ", mt_tg)));
            mt_cmp_val = mt_tv;
        }
        // Generate arm labels
        let mt_default: string = cg_fresh(lc, "match.default");
        // Cascading comparisons
        let mut mt_ai: int = 0;
        while mt_ai < s.n3 {
            let mt_arm: MatchArm = arms_pool[idx_lists[s.n2 + mt_ai]];
            let mt_pat: Pattern = pats[mt_arm.pat_idx];
            let mt_arm_lbl: string = str_concat("match.arm.", int_to_str(mt_ai));
            let mt_next: string = str_concat("match.check.", int_to_str(mt_ai + 1));
            let mut mt_fallthrough: string = mt_default;
            if mt_ai + 1 < s.n3 { mt_fallthrough = mt_next; }
            // Int literal
            if mt_pat.tag == 2 {
                let mt_c: string = cg_fresh(tc, "%t");
                si(body, str_concat(mt_c, str_concat(" = icmp eq i64 ",
                    str_concat(mt_cmp_val, str_concat(", ", int_to_str(mt_pat.n1))))));
                si(body, str_concat("br i1 ", str_concat(mt_c,
                    str_concat(", label %", str_concat(mt_arm_lbl,
                    str_concat(", label %", mt_fallthrough))))));
            }
            // Bool literal
            if mt_pat.tag == 3 {
                let mt_bc: string = cg_fresh(tc, "%t");
                let mut mt_bv: string = "false";
                if mt_pat.n1 == 1 { mt_bv = "true"; }
                si(body, str_concat(mt_bc, str_concat(" = icmp eq i1 ",
                    str_concat(mt_cmp_val, str_concat(", ", mt_bv)))));
                si(body, str_concat("br i1 ", str_concat(mt_bc,
                    str_concat(", label %", str_concat(mt_arm_lbl,
                    str_concat(", label %", mt_fallthrough))))));
            }
            // Wildcard
            if mt_pat.tag == 1 {
                si(body, str_concat("br label %", mt_arm_lbl));
            }
            // Binding
            if mt_pat.tag == 5 {
                // Check if it's actually an enum variant name
                if mt_is_enum {
                    let mt_ve: string = cg_find_enum(mt_pat.s1, enum_decls, variants);
                    if str_len(mt_ve) > 0 {
                        let mt_vtag: int = cg_variant_tag(mt_pat.s1, enum_decls, variants);
                        let mt_vc: string = cg_fresh(tc, "%t");
                        si(body, str_concat(mt_vc, str_concat(" = icmp eq i32 ",
                            str_concat(mt_cmp_val, str_concat(", ", int_to_str(mt_vtag))))));
                        si(body, str_concat("br i1 ", str_concat(mt_vc,
                            str_concat(", label %", str_concat(mt_arm_lbl,
                            str_concat(", label %", mt_fallthrough))))));
                    } else {
                        si(body, str_concat("br label %", mt_arm_lbl));
                    }
                } else {
                    si(body, str_concat("br label %", mt_arm_lbl));
                }
            }
            // Variant pattern
            if mt_pat.tag == 6 {
                let mt_vt: int = cg_variant_tag(mt_pat.s1, enum_decls, variants);
                let mt_vc2: string = cg_fresh(tc, "%t");
                si(body, str_concat(mt_vc2, str_concat(" = icmp eq i32 ",
                    str_concat(mt_cmp_val, str_concat(", ", int_to_str(mt_vt))))));
                si(body, str_concat("br i1 ", str_concat(mt_vc2,
                    str_concat(", label %", str_concat(mt_arm_lbl,
                    str_concat(", label %", mt_fallthrough))))));
            }
            if mt_ai + 1 < s.n3 {
                sa(body, str_concat(mt_next, ":"));
            }
            mt_ai = mt_ai + 1;
        }
        // Default block
        sa(body, str_concat(mt_default, ":"));
        si(body, "unreachable");
        // Emit arm bodies
        let mut mt_bi: int = 0;
        while mt_bi < s.n3 {
            let mt_arm2: MatchArm = arms_pool[idx_lists[s.n2 + mt_bi]];
            let mt_pat2: Pattern = pats[mt_arm2.pat_idx];
            let mt_albl: string = str_concat("match.arm.", int_to_str(mt_bi));
            sa(body, str_concat(mt_albl, ":"));
            let mut mt_atm: [int] = term;
            mt_atm[0] = 0;
            cg_push_scope(scopes);
            // Bind pattern variables
            if mt_pat2.tag == 5 {
                // Binding — check it's not an enum variant name
                let mut mt_is_var: bool = true;
                if mt_is_enum {
                    let mt_chk: string = cg_find_enum(mt_pat2.s1, enum_decls, variants);
                    if str_len(mt_chk) > 0 { mt_is_var = false; }
                }
                if mt_is_var {
                    let mut mt_bty: string = "i64";
                    if mt_is_enum { mt_bty = "i32"; }
                    let mt_bp: string = str_concat("%", str_concat(mt_pat2.s1, ".match.addr"));
                    si(body, str_concat(mt_bp, str_concat(" = alloca ", mt_bty)));
                    si(body, str_concat("store ", str_concat(mt_bty, str_concat(" ",
                        str_concat(mt_cmp_val, str_concat(", ptr ", mt_bp))))));
                    cg_def_var(scopes, vptrs, vtys, vtids, mt_pat2.s1, mt_bp, mt_bty, 1);
                }
            }
            // Variant pattern — extract payload
            if mt_pat2.tag == 6 {
                if mt_is_enum {
                    if mt_pat2.n2 > 0 {
                        let mt_en2: string = nt[mt_stid - 100];
                        let mt_plg: string = cg_fresh(tc, "%t");
                        si(body, str_concat(mt_plg, str_concat(" = getelementptr %",
                            str_concat(mt_en2, str_concat(", ptr ",
                            str_concat(mt_subj_ptr, ", i32 0, i32 1"))))));
                        let mut mt_poff: int = 0;
                        let mut mt_pi: int = 0;
                        while mt_pi < mt_pat2.n2 {
                            let mt_subpat: Pattern = pats[idx_lists[mt_pat2.n1 + mt_pi]];
                            // Get variant field type
                            let mt_vname: string = mt_pat2.s1;
                            let mut mt_fty: string = "i64";
                            // Find variant in enum_decls to get field type
                            let mut mt_edi: int = 0;
                            while mt_edi < len(enum_decls) {
                                let mt_ed: EnumDecl = enum_decls[mt_edi];
                                let mut mt_vdi: int = 0;
                                while mt_vdi < mt_ed.variant_count {
                                    let mt_vr: Variant = variants[mt_ed.variant_start + mt_vdi];
                                    if str_eq(mt_vr.name, mt_vname) {
                                        if mt_pi < mt_vr.field_count {
                                            let mt_ftid: int = resolve_type(
                                                idx_lists[mt_vr.field_start + mt_pi], types, tn);
                                            mt_fty = cg_type(mt_ftid, nt);
                                        }
                                    }
                                    mt_vdi = mt_vdi + 1;
                                }
                                mt_edi = mt_edi + 1;
                            }
                            if mt_subpat.tag == 5 {
                                let mt_fp: string = cg_fresh(tc, "%t");
                                si(body, str_concat(mt_fp, str_concat(
                                    " = getelementptr [0 x i8], ptr ",
                                    str_concat(mt_plg, str_concat(
                                    ", i64 0, i64 ", int_to_str(mt_poff))))));
                                let mt_fval: string = cg_fresh(tc, "%t");
                                si(body, str_concat(mt_fval, str_concat(" = load ",
                                    str_concat(mt_fty, str_concat(", ptr ", mt_fp)))));
                                let mt_fbp: string = str_concat("%",
                                    str_concat(mt_subpat.s1, ".match.addr"));
                                si(body, str_concat(mt_fbp, str_concat(" = alloca ", mt_fty)));
                                si(body, str_concat("store ", str_concat(mt_fty, str_concat(" ",
                                    str_concat(mt_fval, str_concat(", ptr ", mt_fbp))))));
                                cg_def_var(scopes, vptrs, vtys, vtids,
                                    mt_subpat.s1, mt_fbp, mt_fty, 1);
                            }
                            mt_poff = mt_poff + cg_sizeof(mt_fty, struct_decls, fields, types, tn, nt);
                            mt_pi = mt_pi + 1;
                        }
                    }
                }
            }
            cg_block(mt_arm2.body_idx, blocks, stmts, exprs, idx_lists,
                pats, arms_pool, body, globals, tc, lc, sc,
                scopes, vptrs, vtys, vtids, arr_map, arr_etypes,
                struct_decls, fields, types, enum_decls, variants,
                fn_ret_map, nt, tn, term, ret_ty);
            if term[0] == 0 {
                si(body, str_concat("br label %", mt_merge));
            }
            cg_pop_scope(scopes);
            mt_bi = mt_bi + 1;
        }
        sa(body, str_concat(mt_merge, ":"));
        let mut mt_mtm: [int] = term;
        mt_mtm[0] = 0;
        return 0;
    }
    // ExprStmt
    if s.tag == 8 {
        cg_expr(s.n1, exprs, idx_lists, body, globals,
            tc, lc, sc, scopes, vptrs, vtys, vtids,
            arr_map, arr_etypes, struct_decls, fields, types,
            enum_decls, variants, fn_ret_map, nt, tn, term);
        return 0;
    }
}

// ═══════════════════════════════════════════════════════════════
//  Codegen: Builtin Helpers
// ═══════════════════════════════════════════════════════════════

fn cg_builtins(body: [string]) -> int {
    // print_int
    sa(body, "define void @print_int(i64 %x) {{");
    sa(body, "entry:");
    si(body, "call i32 (ptr, ...) @printf(ptr @.fmt.int, i64 %x)");
    si(body, "ret void");
    sa(body, "}}");
    sa(body, "");
    // print_float
    sa(body, "define void @print_float(double %x) {{");
    sa(body, "entry:");
    si(body, "call i32 (ptr, ...) @printf(ptr @.fmt.float, double %x)");
    si(body, "ret void");
    sa(body, "}}");
    sa(body, "");
    // print_bool
    sa(body, "define void @print_bool(i1 %x) {{");
    sa(body, "entry:");
    si(body, "br i1 %x, label %is_true, label %is_false");
    sa(body, "is_true:");
    si(body, "call i32 (ptr, ...) @printf(ptr @.fmt.true)");
    si(body, "ret void");
    sa(body, "is_false:");
    si(body, "call i32 (ptr, ...) @printf(ptr @.fmt.false)");
    si(body, "ret void");
    sa(body, "}}");
    sa(body, "");
    // print_str
    sa(body, "define void @print_str(ptr %s) {{");
    sa(body, "entry:");
    si(body, "call i32 @puts(ptr %s)");
    si(body, "ret void");
    sa(body, "}}");
    sa(body, "");
    // __yorum_bounds_check
    sa(body, "define void @__yorum_bounds_check(i64 %idx, i64 %len) {{");
    sa(body, "entry:");
    si(body, "%neg = icmp slt i64 %idx, 0");
    si(body, "br i1 %neg, label %fail, label %check_upper");
    sa(body, "check_upper:");
    si(body, "%oob = icmp sge i64 %idx, %len");
    si(body, "br i1 %oob, label %fail, label %ok");
    sa(body, "fail:");
    si(body, "call i32 (ptr, ...) @printf(ptr @.fmt.bounds, i64 %idx, i64 %len)");
    si(body, "call void @abort()");
    si(body, "unreachable");
    sa(body, "ok:");
    si(body, "ret void");
    sa(body, "}}");
    sa(body, "");
    // str_len
    sa(body, "define i64 @str_len(ptr %s) {{");
    sa(body, "entry:");
    si(body, "%len = call i64 @strlen(ptr %s)");
    si(body, "ret i64 %len");
    sa(body, "}}");
    sa(body, "");
    // str_concat
    sa(body, "define ptr @str_concat(ptr %a, ptr %b) {{");
    sa(body, "entry:");
    si(body, "%la = call i64 @strlen(ptr %a)");
    si(body, "%lb = call i64 @strlen(ptr %b)");
    si(body, "%sum = add i64 %la, %lb");
    si(body, "%total = add i64 %sum, 1");
    si(body, "%buf = call ptr @malloc(i64 %total)");
    si(body, "call ptr @strcpy(ptr %buf, ptr %a)");
    si(body, "call ptr @strcat(ptr %buf, ptr %b)");
    si(body, "ret ptr %buf");
    sa(body, "}}");
    sa(body, "");
    // str_eq
    sa(body, "define i1 @str_eq(ptr %a, ptr %b) {{");
    sa(body, "entry:");
    si(body, "%cmp = call i32 @strcmp(ptr %a, ptr %b)");
    si(body, "%eq = icmp eq i32 %cmp, 0");
    si(body, "ret i1 %eq");
    sa(body, "}}");
    sa(body, "");
    // __yorum_contract_fail
    sa(body, "define void @__yorum_contract_fail(ptr %msg) {{");
    sa(body, "entry:");
    si(body, "call i32 (ptr, ...) @printf(ptr @.fmt.contract, ptr %msg)");
    si(body, "call void @abort()");
    si(body, "unreachable");
    sa(body, "}}");
    sa(body, "");
    // print_char
    sa(body, "define void @print_char(i8 %c) {{");
    sa(body, "entry:");
    si(body, "%ext = zext i8 %c to i32");
    si(body, "call i32 @putchar(i32 %ext)");
    si(body, "ret void");
    sa(body, "}}");
    sa(body, "");
    // char_to_int
    sa(body, "define i64 @char_to_int(i8 %c) {{");
    sa(body, "entry:");
    si(body, "%ext = zext i8 %c to i64");
    si(body, "ret i64 %ext");
    sa(body, "}}");
    sa(body, "");
    // int_to_char
    sa(body, "define i8 @int_to_char(i64 %n) {{");
    sa(body, "entry:");
    si(body, "%trunc = trunc i64 %n to i8");
    si(body, "ret i8 %trunc");
    sa(body, "}}");
    sa(body, "");
    // int_to_float
    sa(body, "define double @int_to_float(i64 %n) {{");
    sa(body, "entry:");
    si(body, "%f = sitofp i64 %n to double");
    si(body, "ret double %f");
    sa(body, "}}");
    sa(body, "");
    // float_to_int
    sa(body, "define i64 @float_to_int(double %f) {{");
    sa(body, "entry:");
    si(body, "%n = fptosi double %f to i64");
    si(body, "ret i64 %n");
    sa(body, "}}");
    sa(body, "");
    // int_to_str
    sa(body, "define ptr @int_to_str(i64 %n) {{");
    sa(body, "entry:");
    si(body, "%buf = call ptr @malloc(i64 24)");
    si(body, "call i32 (ptr, i64, ptr, ...) @snprintf(ptr %buf, i64 24, ptr @.fmt.lld, i64 %n)");
    si(body, "ret ptr %buf");
    sa(body, "}}");
    sa(body, "");
    // str_to_int
    sa(body, "define i64 @str_to_int(ptr %s) {{");
    sa(body, "entry:");
    si(body, "%n = call i64 @atol(ptr %s)");
    si(body, "ret i64 %n");
    sa(body, "}}");
    sa(body, "");
    // str_charAt
    sa(body, "define i8 @str_charAt(ptr %s, i64 %i) {{");
    sa(body, "entry:");
    si(body, "%len = call i64 @strlen(ptr %s)");
    si(body, "call void @__yorum_bounds_check(i64 %i, i64 %len)");
    si(body, "%ptr = getelementptr i8, ptr %s, i64 %i");
    si(body, "%c = load i8, ptr %ptr");
    si(body, "ret i8 %c");
    sa(body, "}}");
    sa(body, "");
    // str_sub
    sa(body, "define ptr @str_sub(ptr %s, i64 %start, i64 %len) {{");
    sa(body, "entry:");
    si(body, "%total = add i64 %len, 1");
    si(body, "%buf = call ptr @malloc(i64 %total)");
    si(body, "%src = getelementptr i8, ptr %s, i64 %start");
    si(body, "call ptr @memcpy(ptr %buf, ptr %src, i64 %len)");
    si(body, "%end = getelementptr i8, ptr %buf, i64 %len");
    si(body, "store i8 0, ptr %end");
    si(body, "ret ptr %buf");
    sa(body, "}}");
    sa(body, "");
    // str_from_char
    sa(body, "define ptr @str_from_char(i8 %c) {{");
    sa(body, "entry:");
    si(body, "%buf = call ptr @malloc(i64 2)");
    si(body, "store i8 %c, ptr %buf");
    si(body, "%end = getelementptr i8, ptr %buf, i64 1");
    si(body, "store i8 0, ptr %end");
    si(body, "ret ptr %buf");
    sa(body, "}}");
    sa(body, "");
    // char_is_alpha
    sa(body, "define i1 @char_is_alpha(i8 %c) {{");
    sa(body, "entry:");
    si(body, "%ge_a = icmp sge i8 %c, 97");
    si(body, "%le_z = icmp sle i8 %c, 122");
    si(body, "%lower = and i1 %ge_a, %le_z");
    si(body, "%ge_A = icmp sge i8 %c, 65");
    si(body, "%le_Z = icmp sle i8 %c, 90");
    si(body, "%upper = and i1 %ge_A, %le_Z");
    si(body, "%result = or i1 %lower, %upper");
    si(body, "ret i1 %result");
    sa(body, "}}");
    sa(body, "");
    // char_is_digit
    sa(body, "define i1 @char_is_digit(i8 %c) {{");
    sa(body, "entry:");
    si(body, "%ge_0 = icmp sge i8 %c, 48");
    si(body, "%le_9 = icmp sle i8 %c, 57");
    si(body, "%result = and i1 %ge_0, %le_9");
    si(body, "ret i1 %result");
    sa(body, "}}");
    sa(body, "");
    // char_is_whitespace
    sa(body, "define i1 @char_is_whitespace(i8 %c) {{");
    sa(body, "entry:");
    si(body, "%is_space = icmp eq i8 %c, 32");
    si(body, "%is_tab = icmp eq i8 %c, 9");
    si(body, "%is_nl = icmp eq i8 %c, 10");
    si(body, "%is_cr = icmp eq i8 %c, 13");
    si(body, "%or1 = or i1 %is_space, %is_tab");
    si(body, "%or2 = or i1 %or1, %is_nl");
    si(body, "%result = or i1 %or2, %is_cr");
    si(body, "ret i1 %result");
    sa(body, "}}");
    sa(body, "");
    // file_read
    sa(body, "define ptr @file_read(ptr %path) {{");
    sa(body, "entry:");
    si(body, "%f = call ptr @fopen(ptr %path, ptr @.str.r)");
    si(body, "%is_null = icmp eq ptr %f, null");
    si(body, "br i1 %is_null, label %fail, label %opened");
    sa(body, "fail:");
    si(body, "%empty = call ptr @malloc(i64 1)");
    si(body, "store i8 0, ptr %empty");
    si(body, "ret ptr %empty");
    sa(body, "opened:");
    si(body, "call i32 @fseek(ptr %f, i64 0, i32 2)");
    si(body, "%size = call i64 @ftell(ptr %f)");
    si(body, "call i32 @fseek(ptr %f, i64 0, i32 0)");
    si(body, "%buf_size = add i64 %size, 1");
    si(body, "%buf = call ptr @malloc(i64 %buf_size)");
    si(body, "call i64 @fread(ptr %buf, i64 1, i64 %size, ptr %f)");
    si(body, "%end = getelementptr i8, ptr %buf, i64 %size");
    si(body, "store i8 0, ptr %end");
    si(body, "call i32 @fclose(ptr %f)");
    si(body, "ret ptr %buf");
    sa(body, "}}");
    sa(body, "");
    // file_write
    sa(body, "define i1 @file_write(ptr %path, ptr %content) {{");
    sa(body, "entry:");
    si(body, "%f = call ptr @fopen(ptr %path, ptr @.str.w)");
    si(body, "%is_null = icmp eq ptr %f, null");
    si(body, "br i1 %is_null, label %fail, label %opened");
    sa(body, "fail:");
    si(body, "ret i1 0");
    sa(body, "opened:");
    si(body, "%len = call i64 @strlen(ptr %content)");
    si(body, "%written = call i64 @fwrite(ptr %content, i64 1, i64 %len, ptr %f)");
    si(body, "call i32 @fclose(ptr %f)");
    si(body, "%ok = icmp eq i64 %written, %len");
    si(body, "ret i1 %ok");
    sa(body, "}}");
    sa(body, "");
    // print_err
    sa(body, "define void @print_err(ptr %s) {{");
    sa(body, "entry:");
    si(body, "%len = call i64 @strlen(ptr %s)");
    si(body, "call i64 @write(i32 2, ptr %s, i64 %len)");
    si(body, "call i64 @write(i32 2, ptr @.str.newline, i64 1)");
    si(body, "ret void");
    sa(body, "}}");
    sa(body, "");
    // __yorum_hash_string (FNV-1a)
    sa(body, "define i64 @__yorum_hash_string(ptr %s) {{");
    sa(body, "entry:");
    si(body, "br label %loop");
    sa(body, "loop:");
    si(body, "%i = phi i64 [ 0, %entry ], [ %i_next, %cont ]");
    si(body, "%h = phi i64 [ -3750763034362895579, %entry ], [ %h3, %cont ]");
    si(body, "%cp = getelementptr i8, ptr %s, i64 %i");
    si(body, "%c = load i8, ptr %cp");
    si(body, "%done = icmp eq i8 %c, 0");
    si(body, "br i1 %done, label %end, label %cont");
    sa(body, "cont:");
    si(body, "%cv = zext i8 %c to i64");
    si(body, "%h2 = xor i64 %h, %cv");
    si(body, "%h3 = mul i64 %h2, 1099511628211");
    si(body, "%i_next = add i64 %i, 1");
    si(body, "br label %loop");
    sa(body, "end:");
    si(body, "ret i64 %h");
    sa(body, "}}");
    sa(body, "");
    // __yorum_map_find_slot
    sa(body, "define i64 @__yorum_map_find_slot(ptr %map, ptr %key, i64 %cap) {{");
    sa(body, "entry:");
    si(body, "%hash = call i64 @__yorum_hash_string(ptr %key)");
    si(body, "%mask = sub i64 %cap, 1");
    si(body, "%start = and i64 %hash, %mask");
    si(body, "%keys_p = load ptr, ptr %map");
    si(body, "%flags_pp = getelementptr i8, ptr %map, i64 16");
    si(body, "%flags_p = load ptr, ptr %flags_pp");
    si(body, "br label %probe");
    sa(body, "probe:");
    si(body, "%idx = phi i64 [ %start, %entry ], [ %next, %advance ]");
    si(body, "%fp = getelementptr i8, ptr %flags_p, i64 %idx");
    si(body, "%flag = load i8, ptr %fp");
    si(body, "%is_empty = icmp eq i8 %flag, 0");
    si(body, "br i1 %is_empty, label %done, label %check_key");
    sa(body, "check_key:");
    si(body, "%kp = getelementptr ptr, ptr %keys_p, i64 %idx");
    si(body, "%k = load ptr, ptr %kp");
    si(body, "%cmp = call i32 @strcmp(ptr %k, ptr %key)");
    si(body, "%eq = icmp eq i32 %cmp, 0");
    si(body, "br i1 %eq, label %done, label %advance");
    sa(body, "advance:");
    si(body, "%next_raw = add i64 %idx, 1");
    si(body, "%next = and i64 %next_raw, %mask");
    si(body, "br label %probe");
    sa(body, "done:");
    si(body, "ret i64 %idx");
    sa(body, "}}");
    sa(body, "");
    // __yorum_map_grow
    sa(body, "define void @__yorum_map_grow(ptr %map) {{");
    sa(body, "entry:");
    si(body, "%cap_p = getelementptr i8, ptr %map, i64 24");
    si(body, "%old_cap = load i64, ptr %cap_p");
    si(body, "%new_cap = mul i64 %old_cap, 2");
    si(body, "%kb = mul i64 %new_cap, 8");
    si(body, "%vb = mul i64 %new_cap, 8");
    si(body, "%new_keys = call ptr @malloc(i64 %kb)");
    si(body, "%new_vals = call ptr @malloc(i64 %vb)");
    si(body, "%new_flags = call ptr @malloc(i64 %new_cap)");
    si(body, "call ptr @memset(ptr %new_flags, i32 0, i64 %new_cap)");
    si(body, "%old_keys = load ptr, ptr %map");
    si(body, "%vals_p = getelementptr i8, ptr %map, i64 8");
    si(body, "%old_vals = load ptr, ptr %vals_p");
    si(body, "%flags_p = getelementptr i8, ptr %map, i64 16");
    si(body, "%old_flags = load ptr, ptr %flags_p");
    si(body, "store ptr %new_keys, ptr %map");
    si(body, "store ptr %new_vals, ptr %vals_p");
    si(body, "store ptr %new_flags, ptr %flags_p");
    si(body, "store i64 %new_cap, ptr %cap_p");
    si(body, "br label %rehash_loop");
    sa(body, "rehash_loop:");
    si(body, "%i = phi i64 [ 0, %entry ], [ %i_next, %rehash_cont ]");
    si(body, "%cmp = icmp slt i64 %i, %old_cap");
    si(body, "br i1 %cmp, label %rehash_body, label %rehash_done");
    sa(body, "rehash_body:");
    si(body, "%ofp = getelementptr i8, ptr %old_flags, i64 %i");
    si(body, "%of = load i8, ptr %ofp");
    si(body, "%occ = icmp eq i8 %of, 1");
    si(body, "br i1 %occ, label %rehash_insert, label %rehash_cont");
    sa(body, "rehash_insert:");
    si(body, "%okp = getelementptr ptr, ptr %old_keys, i64 %i");
    si(body, "%ok = load ptr, ptr %okp");
    si(body, "%ovp = getelementptr i64, ptr %old_vals, i64 %i");
    si(body, "%ov = load i64, ptr %ovp");
    si(body, "%slot = call i64 @__yorum_map_find_slot(ptr %map, ptr %ok, i64 %new_cap)");
    si(body, "%nkp = getelementptr ptr, ptr %new_keys, i64 %slot");
    si(body, "store ptr %ok, ptr %nkp");
    si(body, "%nvp = getelementptr i64, ptr %new_vals, i64 %slot");
    si(body, "store i64 %ov, ptr %nvp");
    si(body, "%nfp = getelementptr i8, ptr %new_flags, i64 %slot");
    si(body, "store i8 1, ptr %nfp");
    si(body, "br label %rehash_cont");
    sa(body, "rehash_cont:");
    si(body, "%i_next = add i64 %i, 1");
    si(body, "br label %rehash_loop");
    sa(body, "rehash_done:");
    si(body, "call void @free(ptr %old_keys)");
    si(body, "call void @free(ptr %old_vals)");
    si(body, "call void @free(ptr %old_flags)");
    si(body, "ret void");
    sa(body, "}}");
    sa(body, "");
    // map_new
    sa(body, "define ptr @map_new() {{");
    sa(body, "entry:");
    si(body, "%map = call ptr @malloc(i64 40)");
    si(body, "%keys = call ptr @malloc(i64 128)");
    si(body, "%vals = call ptr @malloc(i64 128)");
    si(body, "%flags = call ptr @malloc(i64 16)");
    si(body, "call ptr @memset(ptr %flags, i32 0, i64 16)");
    si(body, "store ptr %keys, ptr %map");
    si(body, "%vp = getelementptr i8, ptr %map, i64 8");
    si(body, "store ptr %vals, ptr %vp");
    si(body, "%fp = getelementptr i8, ptr %map, i64 16");
    si(body, "store ptr %flags, ptr %fp");
    si(body, "%cp = getelementptr i8, ptr %map, i64 24");
    si(body, "store i64 16, ptr %cp");
    si(body, "%sp = getelementptr i8, ptr %map, i64 32");
    si(body, "store i64 0, ptr %sp");
    si(body, "ret ptr %map");
    sa(body, "}}");
    sa(body, "");
    // map_set
    sa(body, "define void @map_set(ptr %map, ptr %key, i64 %val) {{");
    sa(body, "entry:");
    si(body, "%sp = getelementptr i8, ptr %map, i64 32");
    si(body, "%size = load i64, ptr %sp");
    si(body, "%cap_p = getelementptr i8, ptr %map, i64 24");
    si(body, "%cap = load i64, ptr %cap_p");
    si(body, "%s4 = mul i64 %size, 4");
    si(body, "%c3 = mul i64 %cap, 3");
    si(body, "%need_grow = icmp sge i64 %s4, %c3");
    si(body, "br i1 %need_grow, label %grow, label %find");
    sa(body, "grow:");
    si(body, "call void @__yorum_map_grow(ptr %map)");
    si(body, "br label %find");
    sa(body, "find:");
    si(body, "%cap2 = load i64, ptr %cap_p");
    si(body, "%slot = call i64 @__yorum_map_find_slot(ptr %map, ptr %key, i64 %cap2)");
    si(body, "%flags_pp = getelementptr i8, ptr %map, i64 16");
    si(body, "%flags_p = load ptr, ptr %flags_pp");
    si(body, "%fslot = getelementptr i8, ptr %flags_p, i64 %slot");
    si(body, "%flag = load i8, ptr %fslot");
    si(body, "%is_new = icmp eq i8 %flag, 0");
    si(body, "br i1 %is_new, label %insert, label %update");
    sa(body, "insert:");
    si(body, "%klen = call i64 @strlen(ptr %key)");
    si(body, "%kbuf_sz = add i64 %klen, 1");
    si(body, "%kbuf = call ptr @malloc(i64 %kbuf_sz)");
    si(body, "call ptr @strcpy(ptr %kbuf, ptr %key)");
    si(body, "%keys_p = load ptr, ptr %map");
    si(body, "%kslot = getelementptr ptr, ptr %keys_p, i64 %slot");
    si(body, "store ptr %kbuf, ptr %kslot");
    si(body, "store i8 1, ptr %fslot");
    si(body, "%new_size = add i64 %size, 1");
    si(body, "store i64 %new_size, ptr %sp");
    si(body, "br label %store_val");
    sa(body, "update:");
    si(body, "br label %store_val");
    sa(body, "store_val:");
    si(body, "%vals_pp = getelementptr i8, ptr %map, i64 8");
    si(body, "%vals_p = load ptr, ptr %vals_pp");
    si(body, "%vslot = getelementptr i64, ptr %vals_p, i64 %slot");
    si(body, "store i64 %val, ptr %vslot");
    si(body, "ret void");
    sa(body, "}}");
    sa(body, "");
    // map_get
    sa(body, "define i64 @map_get(ptr %map, ptr %key) {{");
    sa(body, "entry:");
    si(body, "%cap_p = getelementptr i8, ptr %map, i64 24");
    si(body, "%cap = load i64, ptr %cap_p");
    si(body, "%slot = call i64 @__yorum_map_find_slot(ptr %map, ptr %key, i64 %cap)");
    si(body, "%flags_pp = getelementptr i8, ptr %map, i64 16");
    si(body, "%flags_p = load ptr, ptr %flags_pp");
    si(body, "%fp = getelementptr i8, ptr %flags_p, i64 %slot");
    si(body, "%flag = load i8, ptr %fp");
    si(body, "%found = icmp eq i8 %flag, 1");
    si(body, "br i1 %found, label %ok, label %fail");
    sa(body, "fail:");
    si(body, "call i32 (ptr, ...) @printf(ptr @.fmt.map_key, ptr %key)");
    si(body, "call void @abort()");
    si(body, "unreachable");
    sa(body, "ok:");
    si(body, "%vals_pp = getelementptr i8, ptr %map, i64 8");
    si(body, "%vals_p = load ptr, ptr %vals_pp");
    si(body, "%vp = getelementptr i64, ptr %vals_p, i64 %slot");
    si(body, "%v = load i64, ptr %vp");
    si(body, "ret i64 %v");
    sa(body, "}}");
    sa(body, "");
    // map_has
    sa(body, "define i1 @map_has(ptr %map, ptr %key) {{");
    sa(body, "entry:");
    si(body, "%cap_p = getelementptr i8, ptr %map, i64 24");
    si(body, "%cap = load i64, ptr %cap_p");
    si(body, "%slot = call i64 @__yorum_map_find_slot(ptr %map, ptr %key, i64 %cap)");
    si(body, "%flags_pp = getelementptr i8, ptr %map, i64 16");
    si(body, "%flags_p = load ptr, ptr %flags_pp");
    si(body, "%fp = getelementptr i8, ptr %flags_p, i64 %slot");
    si(body, "%flag = load i8, ptr %fp");
    si(body, "%found = icmp eq i8 %flag, 1");
    si(body, "ret i1 %found");
    sa(body, "}}");
    sa(body, "");
    return 0;
}

// ═══════════════════════════════════════════════════════════════
//  Codegen: Function Emission
// ═══════════════════════════════════════════════════════════════

fn cg_fn(fi: int, fn_decls: [FnDecl], par: [Param], blocks: [Block], stmts: [Stmt],
         exprs: [Expr], idx_lists: [int], pats: [Pattern], arms_pool: [MatchArm],
         body: [string], globals: [string], sc: [int],
         struct_decls: [StructDecl], fields: [Field], types: [TypeNode],
         enum_decls: [EnumDecl], variants: [Variant],
         fn_ret_map: Map, nt: [string], tn: Map) -> int {
    let fd: FnDecl = fn_decls[fi];
    let ret_tid: int = resolve_type(fd.ret_type, types, tn);
    let fn_ret: string = cg_type(ret_tid, nt);
    // Build param list string
    let mut param_str: string = "";
    let mut pi: int = 0;
    while pi < fd.param_count {
        let fp: Param = par[fd.param_start + pi];
        let fptid: int = resolve_type(fp.type_idx, types, tn);
        let fpty: string = cg_type(fptid, nt);
        if pi > 0 { param_str = str_concat(param_str, ", "); }
        param_str = str_concat(param_str, str_concat(fpty, str_concat(" %", fp.name)));
        pi = pi + 1;
    }
    if str_eq(fd.name, "main") {
        if fd.param_count > 0 { param_str = str_concat(param_str, ", "); }
        param_str = str_concat(param_str, "i32 %__argc, ptr %__argv");
    }
    // Function header
    sa(body, str_concat("define ", str_concat(fn_ret, str_concat(" @", str_concat(fd.name,
        str_concat("(", str_concat(param_str, ") {{")))))));
    sa(body, "entry:");
    // Store argc/argv for main
    if str_eq(fd.name, "main") {
        si(body, "store i32 %__argc, ptr @__yorum_argc");
        si(body, "store ptr %__argv, ptr @__yorum_argv");
    }
    // Per-function state
    let mut fn_tc: [int] = [0];
    let mut fn_lc: [int] = [0];
    let mut fn_term: [int] = [0];
    let mut fn_scopes: [Map] = [map_new()];
    pop(fn_scopes);
    let mut fn_vptrs: [string] = [""];
    pop(fn_vptrs);
    let mut fn_vtys: [string] = [""];
    pop(fn_vtys);
    let mut fn_vtids: [int] = [0];
    pop(fn_vtids);
    let fn_arr_m: Map = map_new();
    let mut fn_arr_et: [string] = [""];
    pop(fn_arr_et);
    cg_push_scope(fn_scopes);
    // Alloca for each parameter
    let mut pi2: int = 0;
    while pi2 < fd.param_count {
        let fp2: Param = par[fd.param_start + pi2];
        let fptid2: int = resolve_type(fp2.type_idx, types, tn);
        let fpty2: string = cg_type(fptid2, nt);
        if fptid2 >= 1000 {
            // Array param: use directly as fat pointer
            cg_def_var(fn_scopes, fn_vptrs, fn_vtys, fn_vtids,
                fp2.name, str_concat("%", fp2.name), "{{ ptr, i64, i64 }}", fptid2);
            let fn_elem_tid: int = fptid2 - 1000;
            let fn_elem_ty: string = cg_type(fn_elem_tid, nt);
            map_set(fn_arr_m, fp2.name, len(fn_arr_et));
            let mut fn_arr_etm: [string] = fn_arr_et;
            push(fn_arr_etm, fn_elem_ty);
        }
        if fptid2 < 1000 {
            // Normal param: alloca + store
            let fn_paddr: string = str_concat("%", str_concat(fp2.name, ".addr"));
            si(body, str_concat(fn_paddr, str_concat(" = alloca ", fpty2)));
            si(body, str_concat("store ", str_concat(fpty2, str_concat(" %",
                str_concat(fp2.name, str_concat(", ptr ", fn_paddr))))));
            cg_def_var(fn_scopes, fn_vptrs, fn_vtys, fn_vtids,
                fp2.name, fn_paddr, fpty2, fptid2);
        }
        pi2 = pi2 + 1;
    }
    // Emit body
    cg_block(fd.body, blocks, stmts, exprs, idx_lists, pats, arms_pool,
        body, globals, fn_tc, fn_lc, sc, fn_scopes, fn_vptrs, fn_vtys, fn_vtids,
        fn_arr_m, fn_arr_et, struct_decls, fields, types, enum_decls, variants,
        fn_ret_map, nt, tn, fn_term, fn_ret);
    // Default return if not terminated
    if fn_term[0] == 0 {
        if str_eq(fn_ret, "void") {
            si(body, "ret void");
        } else {
            si(body, str_concat("ret ", str_concat(fn_ret, " 0")));
        }
    }
    sa(body, "}}");
    sa(body, "");
    return 0;
}

// ═══════════════════════════════════════════════════════════════
//  Codegen: Orchestration
// ═══════════════════════════════════════════════════════════════

fn codegen(fn_decls: [FnDecl], par: [Param], blocks: [Block], stmts: [Stmt],
           exprs: [Expr], idx_lists: [int], pats: [Pattern], arms_pool: [MatchArm],
           struct_decls: [StructDecl], fields: [Field], types: [TypeNode],
           enum_decls: [EnumDecl], variants: [Variant],
           nt: [string], tn: Map) -> string {
    // Build fn_ret_map: function_name -> return_type_id
    let fn_ret_map: Map = map_new();
    map_set(fn_ret_map, "print_int", 6);
    map_set(fn_ret_map, "print_float", 6);
    map_set(fn_ret_map, "print_bool", 6);
    map_set(fn_ret_map, "print_str", 6);
    map_set(fn_ret_map, "str_len", 1);
    map_set(fn_ret_map, "str_concat", 5);
    map_set(fn_ret_map, "str_eq", 3);
    map_set(fn_ret_map, "print_char", 6);
    map_set(fn_ret_map, "char_to_int", 1);
    map_set(fn_ret_map, "int_to_char", 4);
    map_set(fn_ret_map, "int_to_float", 2);
    map_set(fn_ret_map, "float_to_int", 1);
    map_set(fn_ret_map, "int_to_str", 5);
    map_set(fn_ret_map, "str_to_int", 1);
    map_set(fn_ret_map, "str_charAt", 4);
    map_set(fn_ret_map, "str_sub", 5);
    map_set(fn_ret_map, "str_from_char", 5);
    map_set(fn_ret_map, "char_is_alpha", 3);
    map_set(fn_ret_map, "char_is_digit", 3);
    map_set(fn_ret_map, "char_is_whitespace", 3);
    map_set(fn_ret_map, "file_read", 5);
    map_set(fn_ret_map, "file_write", 3);
    map_set(fn_ret_map, "print_err", 6);
    map_set(fn_ret_map, "map_new", 7);
    map_set(fn_ret_map, "map_set", 6);
    map_set(fn_ret_map, "map_get", 1);
    map_set(fn_ret_map, "map_has", 3);
    // Register user functions
    let mut fri: int = 0;
    while fri < len(fn_decls) {
        let frd: FnDecl = fn_decls[fri];
        let fr_tid: int = resolve_type(frd.ret_type, types, tn);
        map_set(fn_ret_map, frd.name, fr_tid);
        fri = fri + 1;
    }
    // ── Preamble ──
    let preamble: string = "; ModuleID = 'yorumc'\nsource_filename = \"yorumc.yrm\"\n\n";
    // ── Type definitions ──
    let mut type_defs: string = "; -- Type definitions --\n";
    let mut td_si: int = 0;
    while td_si < len(struct_decls) {
        let td_sd: StructDecl = struct_decls[td_si];
        let mut ftypes: string = "";
        let mut td_fi: int = 0;
        while td_fi < td_sd.field_count {
            let td_f: Field = fields[td_sd.field_start + td_fi];
            let td_ft: int = resolve_type(td_f.type_idx, types, tn);
            let td_fty: string = cg_type(td_ft, nt);
            if td_fi > 0 { ftypes = str_concat(ftypes, ", "); }
            ftypes = str_concat(ftypes, td_fty);
            td_fi = td_fi + 1;
        }
        type_defs = str_concat(type_defs, str_concat("%", str_concat(td_sd.name,
            str_concat(" = type {{ ", str_concat(ftypes, " }}\n")))));
        td_si = td_si + 1;
    }
    let mut td_ei: int = 0;
    while td_ei < len(enum_decls) {
        let td_ed: EnumDecl = enum_decls[td_ei];
        let mut td_has_data: bool = false;
        let mut td_max_payload: int = 0;
        let mut td_vi: int = 0;
        while td_vi < td_ed.variant_count {
            let td_v: Variant = variants[td_ed.variant_start + td_vi];
            if td_v.field_count > 0 {
                td_has_data = true;
                let mut td_psz: int = 0;
                let mut td_vfi: int = 0;
                while td_vfi < td_v.field_count {
                    let td_vft: int = resolve_type(idx_lists[td_v.field_start + td_vfi], types, tn);
                    let td_vfty: string = cg_type(td_vft, nt);
                    td_psz = td_psz + cg_sizeof(td_vfty, struct_decls, fields, types, tn, nt);
                    td_vfi = td_vfi + 1;
                }
                if td_psz > td_max_payload { td_max_payload = td_psz; }
            }
            td_vi = td_vi + 1;
        }
        if td_has_data {
            if td_max_payload == 0 { td_max_payload = 8; }
            type_defs = str_concat(type_defs, str_concat("%", str_concat(td_ed.name,
                str_concat(" = type {{ i32, [", str_concat(int_to_str(td_max_payload),
                " x i8] }}\n")))));
        } else {
            type_defs = str_concat(type_defs, str_concat("%", str_concat(td_ed.name,
                " = type {{ i32 }}\n")));
        }
        td_ei = td_ei + 1;
    }
    type_defs = str_concat(type_defs, "\n");
    // ── Globals ──
    let mut globals: [string] = [""];
    sa(globals, "; -- External declarations --");
    sa(globals, "declare i32 @printf(ptr, ...)");
    sa(globals, "declare i32 @puts(ptr)");
    sa(globals, "declare ptr @malloc(i64)");
    sa(globals, "declare void @free(ptr)");
    sa(globals, "declare void @abort()");
    sa(globals, "declare i64 @strlen(ptr)");
    sa(globals, "declare ptr @strcpy(ptr, ptr)");
    sa(globals, "declare ptr @strcat(ptr, ptr)");
    sa(globals, "declare i32 @strcmp(ptr, ptr)");
    sa(globals, "declare ptr @memcpy(ptr, ptr, i64)");
    sa(globals, "declare i32 @snprintf(ptr, i64, ptr, ...)");
    sa(globals, "declare i64 @atol(ptr)");
    sa(globals, "declare i32 @putchar(i32)");
    sa(globals, "declare ptr @realloc(ptr, i64)");
    sa(globals, "declare ptr @fopen(ptr, ptr)");
    sa(globals, "declare i32 @fclose(ptr)");
    sa(globals, "declare i32 @fseek(ptr, i64, i32)");
    sa(globals, "declare i64 @ftell(ptr)");
    sa(globals, "declare i64 @fread(ptr, i64, i64, ptr)");
    sa(globals, "declare i64 @fwrite(ptr, i64, i64, ptr)");
    sa(globals, "declare i64 @write(i32, ptr, i64)");
    sa(globals, "declare void @exit(i32)");
    sa(globals, "declare ptr @memset(ptr, i32, i64)");
    sa(globals, "");
    sa(globals, "@__yorum_argc = internal global i32 0");
    sa(globals, "@__yorum_argv = internal global ptr null");
    sa(globals, "");
    sa(globals, "@.fmt.int = private unnamed_addr constant [6 x i8] c\"%lld\\0A\\00\"");
    sa(globals, "@.fmt.float = private unnamed_addr constant [4 x i8] c\"%f\\0A\\00\"");
    sa(globals, "@.fmt.true = private unnamed_addr constant [6 x i8] c\"true\\0A\\00\"");
    sa(globals, "@.fmt.false = private unnamed_addr constant [7 x i8] c\"false\\0A\\00\"");
    sa(globals, "@.fmt.bounds = private unnamed_addr constant [40 x i8] c\"array index out of bounds: %lld >= %lld\\00\"");
    sa(globals, "@.fmt.contract = private unnamed_addr constant [24 x i8] c\"contract violation: %s\\0A\\00\"");
    sa(globals, "@.fmt.lld = private unnamed_addr constant [5 x i8] c\"%lld\\00\"");
    sa(globals, "@.fmt.pop_empty = private unnamed_addr constant [22 x i8] c\"pop from empty array\\0A\\00\"");
    sa(globals, "@.fmt.map_key = private unnamed_addr constant [25 x i8] c\"map key not found: '%s'\\0A\\00\"");
    sa(globals, "@.str.r = private unnamed_addr constant [2 x i8] c\"r\\00\"");
    sa(globals, "@.str.w = private unnamed_addr constant [2 x i8] c\"w\\00\"");
    sa(globals, "@.str.newline = private unnamed_addr constant [1 x i8] c\"\\0A\"");
    sa(globals, "");
    // ── Body ──
    let mut body: [string] = [""];
    let mut sc: [int] = [0];
    cg_builtins(body);
    let mut cg_fi: int = 0;
    while cg_fi < len(fn_decls) {
        cg_fn(cg_fi, fn_decls, par, blocks, stmts, exprs, idx_lists, pats, arms_pool,
            body, globals, sc, struct_decls, fields, types, enum_decls, variants,
            fn_ret_map, nt, tn);
        cg_fi = cg_fi + 1;
    }
    // Assemble output
    return str_concat(preamble, str_concat(type_defs, str_concat(globals[0], body[0])));
}

// ═══════════════════════════════════════════════════════════════
//  Main entry point
// ═══════════════════════════════════════════════════════════════

fn main() -> int {
    let argv: [string] = args();
    if len(argv) < 2 {
        print_err("usage: yorumc <file.yrm> [-o output.ll]\n");
        exit(1);
    }

    let filename: string = argv[1];
    let source: string = file_read(filename);

    // Lexer
    let mut tokens: [Token] = [make_tok(0, 0, "")];
    pop(tokens);
    tokenize(source, tokens);

    // Parser pools — create inline (can't return arrays from functions due to stack lifetime)
    let mut exprs: [Expr] = [make_expr(0, 0, 0, 0, "")];
    pop(exprs);
    let mut stmts: [Stmt] = [make_stmt(0, 0, 0, 0, 0, "")];
    pop(stmts);
    let mut blocks: [Block] = [make_block(0, 0)];
    pop(blocks);
    let mut types: [TypeNode] = [make_type(0, "", 0)];
    pop(types);
    let mut par: [Param] = [make_param("", 0)];
    pop(par);
    let mut fn_decls: [FnDecl] = [make_fndecl("", 0, 0, 0, 0)];
    pop(fn_decls);
    let mut struct_decls: [StructDecl] = [make_structdecl("", 0, 0)];
    pop(struct_decls);
    let mut flds: [Field] = [make_field("", 0)];
    pop(flds);
    let mut enum_decls: [EnumDecl] = [make_enumdecl("", 0, 0)];
    pop(enum_decls);
    let mut vrnts: [Variant] = [make_variant("", 0, 0)];
    pop(vrnts);
    let mut idx_lists: [int] = [0];
    pop(idx_lists);
    let mut pats: [Pattern] = [make_pattern(0, 0, 0, "")];
    pop(pats);
    let mut arms: [MatchArm] = [make_matcharm(0, 0)];
    pop(arms);

    // Parse
    let mut pos: [int] = [0];
    parse_program(tokens, pos, exprs, stmts, blocks, types, par, fn_decls,
                  struct_decls, flds, enum_decls, vrnts, idx_lists, pats, arms);

    // Type check
    typecheck(fn_decls, struct_decls, enum_decls, par, blocks, stmts, exprs,
              types, flds, vrnts, idx_lists, pats, arms);

    // Build named type registry for codegen
    let mut nt: [string] = [""];
    pop(nt);
    let tn_cg: Map = map_new();
    let mut nt_si: int = 0;
    while nt_si < len(struct_decls) {
        let nt_sd: StructDecl = struct_decls[nt_si];
        map_set(tn_cg, nt_sd.name, len(nt));
        let mut nt_m: [string] = nt;
        push(nt_m, nt_sd.name);
        nt_si = nt_si + 1;
    }
    let mut nt_ei: int = 0;
    while nt_ei < len(enum_decls) {
        let nt_ed: EnumDecl = enum_decls[nt_ei];
        map_set(tn_cg, nt_ed.name, len(nt));
        let mut nt_m2: [string] = nt;
        push(nt_m2, nt_ed.name);
        nt_ei = nt_ei + 1;
    }

    // Code generation
    let ir: string = codegen(fn_decls, par, blocks, stmts, exprs, idx_lists, pats, arms,
                              struct_decls, flds, types, enum_decls, vrnts, nt, tn_cg);

    // Output
    let mut outfile: string = "";
    if len(argv) >= 4 {
        if str_eq(argv[2], "-o") {
            outfile = argv[3];
        }
    }
    if str_eq(outfile, "") {
        print_str(ir);
    } else {
        file_write(outfile, ir);
    }

    return 0;
}
